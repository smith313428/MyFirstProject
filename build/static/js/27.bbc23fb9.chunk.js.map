{"version":3,"sources":["../node_modules/reactstrap/es/Col.js","../node_modules/reactstrap/es/Row.js","../node_modules/reactstrap/es/Card.js","../node_modules/reactstrap/es/Breadcrumb.js","../node_modules/reactstrap/es/BreadcrumbItem.js","../node_modules/react-sortablejs/lib/index.js","../node_modules/react-sortablejs/lib/Sortable.js","../../../utils/src/browser-info.ts","../../../utils/src/utils.ts","../../../sortable/src/PluginManager.ts","../../../sortable/src/EventDispatcher.ts","../../../sortable/src/Sortable.ts","../../../plugins/swap/src/index.ts","../../../sortable/src/Animation.ts","../../../plugins/multi-drag/src/index.ts","../../../plugins/on-spill/src/index.ts","../../../plugins/auto-scroll/src/index.ts","../../src/modular-complete.ts","../node_modules/reactstrap/es/CardBody.js"],"names":["stringOrNumberProp","PropTypes","oneOfType","number","string","columnProps","bool","shape","size","order","offset","propTypes","tag","tagPropType","xs","sm","md","lg","xl","className","cssModule","object","widths","array","defaultProps","getColumnSizeClass","isXs","colWidth","colSize","Col","props","Tag","attributes","_objectWithoutPropertiesLoose","colClasses","forEach","i","columnProp","isObject","_classNames","colSizeInterfix","colClass","push","mapToCssModules","classNames","_colClass","length","classes","React","createElement","_extends","rowColsPropType","noGutters","form","Row","inverse","color","body","outline","innerRef","func","Card","ref","listTag","listClassName","children","node","Breadcrumb","ListTag","label","listClasses","active","BreadcrumbItem","undefined","Sortable","require","default","module","exports","Object","defineProperty","value","_propTypes","_interopRequireDefault","_react","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","get","set","_interopRequireWildcard","_sortablejs","assign","target","arguments","source","apply","this","_objectWithoutProperties","excluded","sourceKeys","keys","indexOf","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","_typeof","Symbol","iterator","constructor","_classCallCheck","instance","Constructor","TypeError","_defineProperties","descriptor","enumerable","configurable","writable","_possibleConstructorReturn","self","_assertThisInitialized","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","ReferenceError","_setPrototypeOf","p","_defineProperty","store","nextSibling","activeComponent","_Component","_getPrototypeOf2","_this","_len","args","Array","_key","concat","protoProps","staticProps","subClass","superClass","create","_inherits","_this2","options","ownKeys","filter","sym","_objectSpread","name","eventHandler","_len2","params","_key2","evt","item","nextElementSibling","onChange","items","sortable","toArray","remote","remoteItems","referenceNode","parentNode","from","insertBefore","remoteOptions","group","pull","removeChild","type","_evt","originalEvent","canMove","setTimeout","nextProps","destroy","_this3","_this$props","Component","style","_default","userAgent","pattern","window","navigator","match","IE11OrLess","Edge","FireFox","Safari","IOS","ChromeForAndroid","captureMode","capture","passive","on","el","event","fn","addEventListener","off","removeEventListener","matches","selector","substring","msMatchesSelector","webkitMatchesSelector","_","getParentOrHost","host","document","nodeType","closest","ctx","includeCTX","_throttleTimeout","R_SPACE","toggleClass","state","classList","replace","css","prop","val","defaultView","getComputedStyle","currentStyle","matrix","selfOnly","appliedTransforms","transform","matrixFn","DOMMatrix","WebKitCSSMatrix","CSSMatrix","MSCSSMatrix","find","tagName","list","getElementsByTagName","n","getWindowScrollingElement","scrollingElement","documentElement","getRect","relativeToContainingBlock","relativeToNonStaticParent","undoScale","container","getBoundingClientRect","elRect","top","left","bottom","right","height","width","innerHeight","innerWidth","containerRect","parseInt","elMatrix","scaleX","a","scaleY","d","isScrolledPast","elSide","parentSide","parent","getParentAutoScrollElement","elSideVal","parentSideVal","getChild","childNum","currentChild","display","ghost","dragged","draggable","lastChild","last","lastElementChild","previousElementSibling","index","nodeName","toUpperCase","clone","getRelativeScrollOffset","offsetLeft","offsetTop","winScroller","scrollLeft","scrollTop","includeSelf","elem","gotSelf","clientWidth","scrollWidth","clientHeight","scrollHeight","elemCSS","overflowX","overflowY","isRectEqual","rect1","rect2","Math","round","throttle","callback","ms","scrollBy","x","y","Polymer","$","jQuery","Zepto","dom","cloneNode","setRect","rect","unsetRect","expando","Date","getTime","plugins","defaults","initializeByDefault","pluginManager","mount","plugin","option","pluginEvent","eventName","eventCanceled","cancel","eventNameGlobal","pluginName","initializePlugins","initialized","modified","modifyOption","getEventProperties","eventProperties","modifiedValue","optionListeners","dispatchEvent","rootEl","targetEl","cloneEl","toEl","fromEl","oldIndex","newIndex","oldDraggableIndex","newDraggableIndex","putSortable","extraEventProperties","onName","charAt","substr","CustomEvent","createEvent","initEvent","bubbles","cancelable","to","pullMode","lastPutMode","allEventProperties","PluginManager","data","bind","dragEl","parentEl","ghostEl","nextEl","lastDownEl","cloneHidden","dragStarted","moved","activeSortable","hideGhostForTarget","_hideGhostForTarget","unhideGhostForTarget","_unhideGhostForTarget","cloneNowHidden","cloneNowShown","dispatchSortableEvent","_dispatchEvent","info","activeGroup","tapEvt","touchEvt","lastDx","lastDy","tapDistanceLeft","tapDistanceTop","lastTarget","lastDirection","targetMoveDistance","ghostRelativeParent","awaitingDragStarted","ignoreNextClick","sortables","pastFirstInvertThresh","isCircumstantialInvert","ghostRelativeParentInitialScroll","_silent","savedInputChecked","documentExists","PositionGhostAbsolutely","CSSFloatProperty","supportDraggable","supportCssPointerEvents","cssText","pointerEvents","_detectDirection","elCSS","elWidth","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","child1","child2","firstChildCSS","secondChildCSS","firstChildWidth","marginLeft","marginRight","secondChildWidth","flexDirection","gridTemplateColumns","split","clear","_prepareGroup","toFn","otherGroup","join","originalGroup","checkPull","checkPut","put","revertClone","preventDefault","stopPropagation","stopImmediatePropagation","lastSwapEl","nearestEmptyInsertDetectEvent","nearest","touches","clientX","clientY","some","threshold","emptyInsertThreshold","ret","_onDragOver","_checkOutsideTargetEl","_isOutsideThisEl","toString","animationCallbackId","animationStates","sort","disabled","handle","test","swapThreshold","invertSwap","invertedSwapThreshold","removeCloneOnHide","direction","ghostClass","chosenClass","dragClass","ignore","preventOnFilter","animation","easing","setData","dataTransfer","textContent","dropBubble","dragoverBubble","dataIdAttr","delay","delayOnTouchOnly","touchStartThreshold","Number","devicePixelRatio","forceFallback","fallbackClass","fallbackOnBody","fallbackTolerance","fallbackOffset","supportPointer","nativeDraggable","_onTapStart","captureAnimationState","slice","child","fromRect","thisAnimationDuration","childMatrix","f","e","addAnimationState","removeAnimationState","splice","arr","animateAll","clearTimeout","animating","animationTime","time","toRect","prevFromRect","prevToRect","animatingRect","targetMatrix","sqrt","pow","animate","max","animationResetTimer","currentRect","duration","translateX","translateY","animatingX","animatingY","forRepaintDummy","offsetWidth","animated","onMove","dragRect","targetRect","willInsertAfter","retVal","onMoveFn","draggedRect","related","relatedRect","_disableDraggable","_unsilent","_generateId","str","src","href","sum","charCodeAt","_nextTick","_cancelNextTick","id","contains","_getDirection","touch","pointerType","originalTarget","shadowRoot","path","composedPath","root","inputs","idx","checked","button","isContentEditable","criteria","trim","_prepareDragStart","dragStartFn","ownerDocument","_lastX","_lastY","_onDrop","_disableDelayedDragEvents","_triggerDragStart","_disableDelayedDrag","_delayedDragTouchMoveHandler","_dragStartTimer","abs","floor","_onTouchMove","_onDragStart","selection","empty","getSelection","removeAllRanges","err","_dragStarted","fallback","_appendGhost","_nulling","_emulateDragOver","elementFromPoint","ghostMatrix","relativeScrollOffset","dx","dy","b","c","cssMatrix","appendChild","_hideClone","cloneId","_loopId","setInterval","effectAllowed","_dragStartId","revert","vertical","isOwner","canSort","fromSortable","completedFired","dragOverEvent","_ignoreWhileAnimating","completed","elLastChild","changed","targetBeforeFirstSwap","sibling","differentLevel","differentRowCol","dragElS1Opp","targetS1Opp","side1","scrolledPastTop","scrollBefore","isLastTarget","mouseOnAxis","targetLength","targetS1","targetS2","invert","dragIndex","after","moveVector","extra","axis","insertion","_showClone","_offMoveEvents","_offUpEvents","clearInterval","save","handleEvent","dropEffect","getAttribute","querySelectorAll","removeAttribute","utils","is","extend","dst","nextTick","cancelNextTick","detectDirection","element","version","lastMultiDragSelect","multiDragSortable","clonesFromRect","clonesHidden","multiDragElements","multiDragClones","initialFolding","folding","insertMultiDragClones","elementsInserted","sortableIndex","removeMultiDragElements","multiDragElement","drop","toSortable","changedTouches","onSpill","Revert","Remove","startIndex","dragStart","parentSortable","scrollEl","scrollRootEl","lastAutoScrollX","lastAutoScrollY","pointerElemChangedInterval","autoScrolls","scrolling","clearAutoScrolls","autoScroll","pid","clearPointerElemChangedInterval","isFallback","scroll","scrollCustomFn","sens","scrollSensitivity","speed","scrollSpeed","scrollThisInstance","scrollFn","layersOut","currentParent","canScrollX","canScrollY","scrollPosX","scrollPosY","vx","vy","layer","scrollOffsetY","scrollOffsetX","bubbleScroll","AutoScroll","_handleAutoScroll","_handleFallbackAutoScroll","dragOverCompleted","dragOverBubble","nulling","ogElemScroller","newElem","RemoveOnSpill","RevertOnSpill","Swap","swapClass","dragOverValid","swap","prevSwapEl","n1","n2","i1","i2","p1","p2","isEqualNode","swapItem","MultiDrag","_deselectMultiDrag","_checkKeyDown","_checkKeyUp","selectedClass","multiDragKey","multiDragKeyDown","isMultiDrag","delayStartGlobal","delayEnded","setupClone","t","showClone","hideClone","dragStartGlobal","multiDrag","dragOver","clonesInserted","dragRectAbsolute","clonesHiddenBefore","dragOverAnimationCapture","dragMatrix","dragOverAnimationComplete","originalEvt","shiftKey","lastIndex","currentIndex","multiDragIndex","update","nullingGlobal","destroyGlobal","shift","select","deselect","oldIndicies","newIndicies","clones","toLowerCase","CardBody"],"mappings":"iHAAA,6EAOIA,EAAqBC,IAAUC,UAAU,CAACD,IAAUE,OAAQF,IAAUG,SACtEC,EAAcJ,IAAUC,UAAU,CAACD,IAAUK,KAAML,IAAUE,OAAQF,IAAUG,OAAQH,IAAUM,MAAM,CACzGC,KAAMP,IAAUC,UAAU,CAACD,IAAUK,KAAML,IAAUE,OAAQF,IAAUG,SACvEK,MAAOT,EACPU,OAAQV,MAENW,EAAY,CACdC,IAAKC,IACLC,GAAIT,EACJU,GAAIV,EACJW,GAAIX,EACJY,GAAIZ,EACJa,GAAIb,EACJc,UAAWlB,IAAUG,OACrBgB,UAAWnB,IAAUoB,OACrBC,OAAQrB,IAAUsB,OAEhBC,EAAe,CACjBZ,IAAK,MACLU,OApBc,CAAC,KAAM,KAAM,KAAM,KAAM,OAuBrCG,EAAqB,SAA4BC,EAAMC,EAAUC,GACnE,OAAgB,IAAZA,GAAgC,KAAZA,EACfF,EAAO,MAAQ,OAASC,EACV,SAAZC,EACFF,EAAO,WAAa,OAASC,EAAW,QAG1CD,EAAO,OAASE,EAAU,OAASD,EAAW,IAAMC,GAGzDC,EAAM,SAAaC,GACrB,IAAIX,EAAYW,EAAMX,UAClBC,EAAYU,EAAMV,UAClBE,EAASQ,EAAMR,OACfS,EAAMD,EAAMlB,IACZoB,EAAaC,YAA8BH,EAAO,CAAC,YAAa,YAAa,SAAU,QAEvFI,EAAa,GACjBZ,EAAOa,SAAQ,SAAUR,EAAUS,GACjC,IAAIC,EAAaP,EAAMH,GAGvB,UAFOK,EAAWL,GAEbU,GAA6B,KAAfA,EAAnB,CAIA,IAAIX,GAAQU,EAEZ,GAAIE,YAASD,GAAa,CACxB,IAAIE,EAEAC,EAAkBd,EAAO,IAAM,IAAMC,EAAW,IAChDc,EAAWhB,EAAmBC,EAAMC,EAAUU,EAAW7B,MAC7D0B,EAAWQ,KAAKC,YAAgBC,MAAYL,EAAc,IAAgBE,GAAYJ,EAAW7B,MAA4B,KAApB6B,EAAW7B,KAAa+B,EAAY,QAAUC,EAAkBH,EAAW5B,OAAS4B,EAAW5B,OAA8B,IAArB4B,EAAW5B,MAAa8B,EAAY,SAAWC,EAAkBH,EAAW3B,QAAU2B,EAAW3B,QAAgC,IAAtB2B,EAAW3B,OAAc6B,IAAenB,QAC/V,CACL,IAAIyB,EAAYpB,EAAmBC,EAAMC,EAAUU,GAEnDH,EAAWQ,KAAKG,QAIfX,EAAWY,QACdZ,EAAWQ,KAAK,OAGlB,IAAIK,EAAUJ,YAAgBC,IAAWzB,EAAWe,GAAad,GACjE,OAAoB4B,IAAMC,cAAclB,EAAKmB,YAAS,GAAIlB,EAAY,CACpEb,UAAW4B,MAIflB,EAAIlB,UAAYA,EAChBkB,EAAIL,aAAeA,EACJK,O,iCClFf,6EAOIsB,EAAkBlD,IAAUC,UAAU,CAACD,IAAUE,OAAQF,IAAUG,SACnEO,EAAY,CACdC,IAAKC,IACLuC,UAAWnD,IAAUK,KACrBa,UAAWlB,IAAUG,OACrBgB,UAAWnB,IAAUoB,OACrBgC,KAAMpD,IAAUK,KAChBQ,GAAIqC,EACJpC,GAAIoC,EACJnC,GAAImC,EACJlC,GAAIkC,EACJjC,GAAIiC,GAEF3B,EAAe,CACjBZ,IAAK,MACLU,OAhBiB,CAAC,KAAM,KAAM,KAAM,KAAM,OAmBxCgC,EAAM,SAAaxB,GACrB,IAAIX,EAAYW,EAAMX,UAClBC,EAAYU,EAAMV,UAClBgC,EAAYtB,EAAMsB,UAClBrB,EAAMD,EAAMlB,IACZyC,EAAOvB,EAAMuB,KACb/B,EAASQ,EAAMR,OACfU,EAAaC,YAA8BH,EAAO,CAAC,YAAa,YAAa,YAAa,MAAO,OAAQ,WAEzGI,EAAa,GACjBZ,EAAOa,SAAQ,SAAUR,EAAUS,GACjC,IAAIR,EAAUE,EAAMH,GAGpB,UAFOK,EAAWL,GAEbC,EAAL,CAIA,IAAIF,GAAQU,EACZF,EAAWQ,KAAKhB,EAAO,YAAcE,EAAU,YAAcD,EAAW,IAAMC,OAEhF,IAAImB,EAAUJ,YAAgBC,IAAWzB,EAAWiC,EAAY,aAAe,KAAMC,EAAO,WAAa,MAAOnB,GAAad,GAC7H,OAAoB4B,IAAMC,cAAclB,EAAKmB,YAAS,GAAIlB,EAAY,CACpEb,UAAW4B,MAIfO,EAAI3C,UAAYA,EAChB2C,EAAI9B,aAAeA,EACJ8B,O,iCCtDf,6EAMI3C,EAAY,CACdC,IAAKC,IACL0C,QAAStD,IAAUK,KACnBkD,MAAOvD,IAAUG,OACjBqD,KAAMxD,IAAUK,KAChBoD,QAASzD,IAAUK,KACnBa,UAAWlB,IAAUG,OACrBgB,UAAWnB,IAAUoB,OACrBsC,SAAU1D,IAAUC,UAAU,CAACD,IAAUoB,OAAQpB,IAAUG,OAAQH,IAAU2D,QAM3EC,EAAO,SAAc/B,GACvB,IAAIX,EAAYW,EAAMX,UAClBC,EAAYU,EAAMV,UAClBoC,EAAQ1B,EAAM0B,MACdC,EAAO3B,EAAM2B,KACbF,EAAUzB,EAAMyB,QAChBG,EAAU5B,EAAM4B,QAChB3B,EAAMD,EAAMlB,IACZ+C,EAAW7B,EAAM6B,SACjB3B,EAAaC,YAA8BH,EAAO,CAAC,YAAa,YAAa,QAAS,OAAQ,UAAW,UAAW,MAAO,aAE3HiB,EAAUJ,YAAgBC,IAAWzB,EAAW,SAAQoC,GAAU,eAAsBE,GAAO,cAAqBD,IAASE,EAAU,SAAW,MAAQ,IAAMF,GAAgBpC,GACpL,OAAoB4B,IAAMC,cAAclB,EAAKmB,YAAS,GAAIlB,EAAY,CACpEb,UAAW4B,EACXe,IAAKH,MAITE,EAAKlD,UAAYA,EACjBkD,EAAKrC,aAvBc,CACjBZ,IAAK,OAuBQiD,O,iCCxCf,6EAMIlD,EAAY,CACdC,IAAKC,IACLkD,QAASlD,IACTM,UAAWlB,IAAUG,OACrB4D,cAAe/D,IAAUG,OACzBgB,UAAWnB,IAAUoB,OACrB4C,SAAUhE,IAAUiE,KACpB,aAAcjE,IAAUG,QAQtB+D,EAAa,SAAoBrC,GACnC,IAAIX,EAAYW,EAAMX,UAClB6C,EAAgBlC,EAAMkC,cACtB5C,EAAYU,EAAMV,UAClB6C,EAAWnC,EAAMmC,SACjBlC,EAAMD,EAAMlB,IACZwD,EAAUtC,EAAMiC,QAChBM,EAAQvC,EAAM,cACdE,EAAaC,YAA8BH,EAAO,CAAC,YAAa,gBAAiB,YAAa,WAAY,MAAO,UAAW,eAE5HiB,EAAUJ,YAAgBC,IAAWzB,GAAYC,GACjDkD,EAAc3B,YAAgBC,IAAW,aAAcoB,GAAgB5C,GAC3E,OAAoB4B,IAAMC,cAAclB,EAAKmB,YAAS,GAAIlB,EAAY,CACpEb,UAAW4B,EACX,aAAcsB,IACCrB,IAAMC,cAAcmB,EAAS,CAC5CjD,UAAWmD,GACVL,KAGLE,EAAWxD,UAAYA,EACvBwD,EAAW3C,aA3BQ,CACjBZ,IAAK,MACLmD,QAAS,KACT,aAAc,cAyBDI,O,iCC3Cf,6EAMIxD,EAAY,CACdC,IAAKC,IACL0D,OAAQtE,IAAUK,KAClBa,UAAWlB,IAAUG,OACrBgB,UAAWnB,IAAUoB,QAMnBmD,EAAiB,SAAwB1C,GAC3C,IAAIX,EAAYW,EAAMX,UAClBC,EAAYU,EAAMV,UAClBmD,EAASzC,EAAMyC,OACfxC,EAAMD,EAAMlB,IACZoB,EAAaC,YAA8BH,EAAO,CAAC,YAAa,YAAa,SAAU,QAEvFiB,EAAUJ,YAAgBC,IAAWzB,IAAWoD,GAAS,SAAkB,mBAAoBnD,GACnG,OAAoB4B,IAAMC,cAAclB,EAAKmB,YAAS,GAAIlB,EAAY,CACpEb,UAAW4B,EACX,eAAgBwB,EAAS,YAASE,MAItCD,EAAe7D,UAAYA,EAC3B6D,EAAehD,aAnBI,CACjBZ,IAAK,MAmBQ4D,O,iCC9Bf,IAAIE,EAAWC,EAAQ,KAAcC,QAErCC,EAAOC,QAAUJ,G,iCCFjBK,OAAOC,eAAeF,EAAS,aAAc,CAC3CG,OAAO,IAETH,EAAQF,aAAU,EAElB,IAAIM,EAAaC,EAAuBR,EAAQ,KAE5CS,EAIJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAc,IAAIE,EAAS,GAAI,GAAW,MAAPF,EAAe,IAAK,IAAIG,KAAOH,EAAO,GAAIN,OAAOU,UAAUC,eAAeC,KAAKN,EAAKG,GAAM,CAAE,IAAII,EAAOb,OAAOC,gBAAkBD,OAAOc,yBAA2Bd,OAAOc,yBAAyBR,EAAKG,GAAO,GAAQI,EAAKE,KAAOF,EAAKG,IAAOhB,OAAOC,eAAeO,EAAQC,EAAKI,GAAgBL,EAAOC,GAAOH,EAAIG,GAAoC,OAAtBD,EAAOX,QAAUS,EAAYE,EAJhcS,CAAwBrB,EAAQ,IAEzCsB,EAAcd,EAAuBR,EAAQ,MAIjD,SAASQ,EAAuBE,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAET,QAASS,GAEvF,SAASnC,IAA2Q,OAA9PA,EAAW6B,OAAOmB,QAAU,SAAUC,GAAU,IAAK,IAAI/D,EAAI,EAAGA,EAAIgE,UAAUtD,OAAQV,IAAK,CAAE,IAAIiE,EAASD,UAAUhE,GAAI,IAAK,IAAIoD,KAAOa,EAActB,OAAOU,UAAUC,eAAeC,KAAKU,EAAQb,KAAQW,EAAOX,GAAOa,EAAOb,IAAY,OAAOW,IAA2BG,MAAMC,KAAMH,WAEhT,SAASI,EAAyBH,EAAQI,GAAY,GAAc,MAAVJ,EAAgB,MAAO,GAAI,IAAkEb,EAAKpD,EAAnE+D,EAEzF,SAAuCE,EAAQI,GAAY,GAAc,MAAVJ,EAAgB,MAAO,GAAI,IAA2Db,EAAKpD,EAA5D+D,EAAS,GAAQO,EAAa3B,OAAO4B,KAAKN,GAAqB,IAAKjE,EAAI,EAAGA,EAAIsE,EAAW5D,OAAQV,IAAOoD,EAAMkB,EAAWtE,GAAQqE,EAASG,QAAQpB,IAAQ,IAAaW,EAAOX,GAAOa,EAAOb,IAAQ,OAAOW,EAFxMlE,CAA8BoE,EAAQI,GAAuB,GAAI1B,OAAO8B,sBAAuB,CAAE,IAAIC,EAAmB/B,OAAO8B,sBAAsBR,GAAS,IAAKjE,EAAI,EAAGA,EAAI0E,EAAiBhE,OAAQV,IAAOoD,EAAMsB,EAAiB1E,GAAQqE,EAASG,QAAQpB,IAAQ,GAAkBT,OAAOU,UAAUsB,qBAAqBpB,KAAKU,EAAQb,KAAgBW,EAAOX,GAAOa,EAAOb,IAAU,OAAOW,EAIne,SAASa,EAAQ3B,GAAwT,OAAtO2B,EAArD,oBAAXC,QAAoD,kBAApBA,OAAOC,SAAmC,SAAiB7B,GAAO,cAAcA,GAA2B,SAAiBA,GAAO,OAAOA,GAAyB,oBAAX4B,QAAyB5B,EAAI8B,cAAgBF,QAAU5B,IAAQ4B,OAAOxB,UAAY,gBAAkBJ,IAAyBA,GAIxV,SAAS+B,EAAgBC,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAIC,UAAU,qCAEhH,SAASC,EAAkBrB,EAAQrE,GAAS,IAAK,IAAIM,EAAI,EAAGA,EAAIN,EAAMgB,OAAQV,IAAK,CAAE,IAAIqF,EAAa3F,EAAMM,GAAIqF,EAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,UAAWF,IAAYA,EAAWG,UAAW,GAAM7C,OAAOC,eAAemB,EAAQsB,EAAWjC,IAAKiC,IAI7S,SAASI,EAA2BC,EAAMnC,GAAQ,OAAIA,GAA2B,WAAlBqB,EAAQrB,IAAsC,oBAATA,EAA8CoC,EAAuBD,GAAtCnC,EAEnI,SAASqC,EAAgBC,GAAwJ,OAAnJD,EAAkBjD,OAAOmD,eAAiBnD,OAAOoD,eAAiB,SAAyBF,GAAK,OAAOA,EAAEG,WAAarD,OAAOoD,eAAeF,KAA8BA,GAExM,SAASF,EAAuBD,GAAQ,QAAa,IAATA,EAAmB,MAAM,IAAIO,eAAe,6DAAgE,OAAOP,EAI/J,SAASQ,EAAgBL,EAAGM,GAA+G,OAA1GD,EAAkBvD,OAAOmD,gBAAkB,SAAyBD,EAAGM,GAAsB,OAAjBN,EAAEG,UAAYG,EAAUN,IAA6BA,EAAGM,GAErK,SAASC,EAAgBnD,EAAKG,EAAKP,GAAiK,OAApJO,KAAOH,EAAON,OAAOC,eAAeK,EAAKG,EAAK,CAAEP,MAAOA,EAAOyC,YAAY,EAAMC,cAAc,EAAMC,UAAU,IAAkBvC,EAAIG,GAAOP,EAAgBI,EAE3M,IAAIoD,EAAQ,CACVC,YAAa,KACbC,gBAAiB,MAGfjE,EAEJ,SAAUkE,GAGR,SAASlE,IACP,IAAImE,EAEAC,EAEJ1B,EAAgBb,KAAM7B,GAEtB,IAAK,IAAIqE,EAAO3C,UAAUtD,OAAQkG,EAAO,IAAIC,MAAMF,GAAOG,EAAO,EAAGA,EAAOH,EAAMG,IAC/EF,EAAKE,GAAQ9C,UAAU8C,GAOzB,OAFAV,EAAgBT,EAFhBe,EAAQjB,EAA2BtB,MAAOsC,EAAmBb,EAAgBtD,IAAWiB,KAAKW,MAAMuC,EAAkB,CAACtC,MAAM4C,OAAOH,MAEpF,WAAY,MAEpDF,EAvCX,IAAsBxB,EAAa8B,EAAYC,EAwI7C,OAhIF,SAAmBC,EAAUC,GAAc,GAA0B,oBAAfA,GAA4C,OAAfA,EAAuB,MAAM,IAAIhC,UAAU,sDAAyD+B,EAAS7D,UAAYV,OAAOyE,OAAOD,GAAcA,EAAW9D,UAAW,CAAE0B,YAAa,CAAElC,MAAOqE,EAAU1B,UAAU,EAAMD,cAAc,KAAe4B,GAAYjB,EAAgBgB,EAAUC,GAcjXE,CAAU/E,EAAUkE,GAtBAtB,EA0CP5C,GA1CoB0E,EA0CV,CAAC,CACtB5D,IAAK,oBACLP,MAAO,WACL,IAAIyE,EAASnD,KAEToD,EArDV,SAAuBxD,GAAU,IAAK,IAAI/D,EAAI,EAAGA,EAAIgE,UAAUtD,OAAQV,IAAK,CAAE,IAAIiE,EAAyB,MAAhBD,UAAUhE,GAAagE,UAAUhE,GAAK,GAAQwH,EAAU7E,OAAO4B,KAAKN,GAAqD,oBAAjCtB,OAAO8B,wBAAwC+C,EAAUA,EAAQT,OAAOpE,OAAO8B,sBAAsBR,GAAQwD,QAAO,SAAUC,GAAO,OAAO/E,OAAOc,yBAAyBQ,EAAQyD,GAAKpC,gBAAmBkC,EAAQzH,SAAQ,SAAUqD,GAAOgD,EAAgBrC,EAAQX,EAAKa,EAAOb,OAAa,OAAOW,EAqDpc4D,CAAc,GAAIxD,KAAKzE,MAAM6H,SAE3C,CAAC,WAAY,UAAW,QAAS,QAAS,WAAY,SAAU,WAAY,WAAY,SAAU,WAAWxH,SAAQ,SAAU6H,GAC7H,IAAIC,EAAeN,EAAQK,GAE3BL,EAAQK,GAAQ,WACd,IAAK,IAAIE,EAAQ9D,UAAUtD,OAAQqH,EAAS,IAAIlB,MAAMiB,GAAQE,EAAQ,EAAGA,EAAQF,EAAOE,IACtFD,EAAOC,GAAShE,UAAUgE,GAG5B,IAAIC,EAAMF,EAAO,GAEjB,GAAa,aAATH,EACFvB,EAAMC,YAAc2B,EAAIC,KAAKC,mBAC7B9B,EAAME,gBAAkBe,OACnB,IAAc,UAATM,GAA6B,aAATA,IAAwBN,EAAO5H,MAAM0I,SAAU,CAC7E,IAAIC,EAAQf,EAAOgB,SAASC,UAExBC,EAASnC,EAAME,gBACfkC,EAAcD,EAAOF,SAASC,UAC9BG,EAAgBrC,EAAMC,aAAgD,OAAjCD,EAAMC,YAAYqC,WAAsBtC,EAAMC,YAAc,KAGrG,GAFA2B,EAAIW,KAAKC,aAAaZ,EAAIC,KAAMQ,GAE5BF,IAAWlB,EAAQ,CACrB,IAAIwB,EAAgBN,EAAO9I,MAAM6H,SAAW,GAEP,WAAjC3C,EAAQkE,EAAcC,QAAoD,UAA7BD,EAAcC,MAAMC,MAEnEf,EAAIC,KAAKS,WAAWM,YAAYhB,EAAIC,MAGtCM,EAAO9I,MAAM0I,UAAYI,EAAO9I,MAAM0I,SAASK,EAAaD,EAAOF,SAAUL,GAG/EX,EAAO5H,MAAM0I,UAAYd,EAAO5H,MAAM0I,SAASC,EAAOf,EAAOgB,SAAUL,GAGzE,GAAiB,SAAbA,EAAIiB,KAAiB,CACvB,IAAIC,EAAOpB,EAAO,GACdqB,EAAgBrB,EAAO,GACvBsB,GAAUxB,GAAeA,EAAasB,EAAMC,GAChD,OAAOC,EAGTC,YAAW,WACTzB,GAAgBA,EAAaI,KAC5B,OAGP9D,KAAKmE,SAAWzE,EAAYrB,QAAQ4E,OAAOjD,KAAKrC,KAAMyF,KAEvD,CACDnE,IAAK,wBACLP,MAAO,SAA+B0G,GAGpC,QAAKA,EAAUnB,WAMhB,CACDhF,IAAK,uBACLP,MAAO,WACDsB,KAAKmE,WACPnE,KAAKmE,SAASkB,UACdrF,KAAKmE,SAAW,QAGnB,CACDlF,IAAK,SACLP,MAAO,WACL,IAAI4G,EAAStF,KAETuF,EAAcvF,KAAKzE,MACnBiK,EAAYD,EAAYlL,IAGxBkB,GAFUgK,EAAYnC,QACXmC,EAAYtB,SACfhE,EAAyBsF,EAAa,CAAC,MAAO,UAAW,cAErE,OAAO1G,EAAOR,QAAQ3B,cAAc8I,EAAW7I,EAAS,GAAIpB,EAAO,CACjEgC,IAAK,SAAaI,GAChB2H,EAAO3H,KAAOA,WAlIsDsD,EAAkBF,EAAY7B,UAAW2D,GAAiBC,GAAa7B,EAAkBF,EAAa+B,GAwI3K3E,EAnHT,CAoHEU,EAAO2G,WAETvD,EAAgB9D,EAAU,YAAa,CACrCiF,QAASzE,EAAWN,QAAQvD,OAC5BmJ,SAAUtF,EAAWN,QAAQhB,KAC7BhD,IAAKsE,EAAWN,QAAQ1E,UAAU,CAACgF,EAAWN,QAAQxE,OAAQ8E,EAAWN,QAAQhB,OACjFoI,MAAO9G,EAAWN,QAAQvD,SAG5BmH,EAAgB9D,EAAU,eAAgB,CACxCiF,QAAS,GACT/I,IAAK,MACLoL,MAAO,KAGT,IAAIC,EAAWvH,EACfI,EAAQF,QAAUqH,G,gPCxLlB,SAASC,EAAUC,GACjB,GAAsB,oBAAXC,QAA0BA,OAAOC,UAC1C,QAAwBA,UAAUH,UAAUI,MAAMH,G,iDAItD,IAAaI,EAAaL,EACxB,yDAEWM,EAAON,EAAU,SACjBO,EAAUP,EAAU,YACpBQ,EACXR,EAAU,aAAeA,EAAU,aAAeA,EAAU,YACjDS,EAAMT,EAAU,mBAChBU,EAAmBV,EAAU,YAAcA,EAAU,YCX5DW,EAAc,CAClBC,WACAC,YAGF,SAASC,EAAGC,EAAIC,EAAOC,GACrBF,EAAGG,iBAAiBF,EAAOC,GAAKZ,GAAcM,GAGhD,SAASQ,EAAIJ,EAAIC,EAAOC,GACtBF,EAAGK,oBAAoBJ,EAAOC,GAAKZ,GAAcM,GAGnD,SAASU,EAAyBN,EAAgBO,GAChD,GAAKA,EAAL,CAIA,GAFgB,MAAhBA,EAAS,KAAeA,EAAWA,EAASC,UAAU,IAElDR,EACF,IACE,GAAIA,EAAGM,QACL,OAAON,EAAGM,QAAQC,MACTP,EAAGS,kBACZ,OAAOT,EAAGS,kBAAkBF,MACnBP,EAAGU,sBACZ,OAAOV,EAAGU,sBAAsBH,GAElC,MAAOI,GACP,SAIJ,UAGF,SAASC,EAAgBZ,GACvB,OAAOA,EAAGa,MAAQb,IAAOc,UAAYd,EAAGa,KAAKE,SACzCf,EAAGa,KACHb,EAAGlC,WAGT,SAASkD,EACUhB,EACLO,EACKU,EACjBC,GAEA,GAAIlB,EAAI,CACNiB,EAAMA,GAAOH,SAEb,EAAG,CACD,GACe,MAAZP,IACkB,MAAhBA,EAAS,GACNP,EAAGlC,aAAemD,GAAOX,EAAQN,EAAIO,GACrCD,EAAQN,EAAIO,KACjBW,GAAclB,IAAOiB,EAEtB,OAAOjB,EAGT,GAAIA,IAAOiB,EAAK,YAERjB,EAAKY,EAAgBZ,IAGjC,YAGF,IA+ZImB,EA/ZEC,EAAU,OAEhB,SAASC,EAAYrB,EAAIjD,EAAMuE,GAC7B,GAAItB,GAAMjD,EACR,GAAIiD,EAAGuB,UACLvB,EAAGuB,UAAUD,EAAQ,MAAQ,UAAUvE,OAClC,CACL,IAAI7I,GAAa,IAAM8L,EAAG9L,UAAY,KACnCsN,QAAQJ,EAAS,KACjBI,QAAQ,IAAMzE,EAAO,IAAK,KAC7BiD,EAAG9L,WAAaA,GAAaoN,EAAQ,IAAMvE,EAAO,KAAKyE,QACrDJ,EACA,MAMR,SAASK,EAAIzB,EAAI0B,EAAMC,GACrB,IAAI5C,EAAQiB,GAAMA,EAAGjB,MAErB,GAAIA,EAAO,CACT,YAAI4C,EAOF,OANIb,SAASc,aAAed,SAASc,YAAYC,iBAC/CF,EAAMb,SAASc,YAAYC,iBAAiB7B,EAAI,IACvCA,EAAG8B,eACZH,EAAM3B,EAAG8B,uBAGJJ,EAAkBC,EAAMA,EAAID,GAE7BA,KAAQ3C,IAAsC,IAA5B2C,EAAK/H,QAAQ,YACnC+H,EAAO,WAAaA,GAGtB3C,EAAM2C,GAAQC,GAAsB,iBAARA,EAAmB,GAAK,OAK1D,SAASI,EAAO/B,EAAIgC,GAClB,IAAIC,EAAoB,GACxB,GAAkB,iBAAPjC,EACTiC,EAAoBjC,OAEpB,EAAG,CAED,IAAIkC,EAAYT,EAAIzB,EAAI,aAEpBkC,GAA2B,SAAdA,IACfD,EAAoBC,EAAY,IAAMD,UAGhCD,IAAahC,EAAKA,EAAGlC,aAGjC,IAAMqE,EACJhD,OAAOiD,WACPjD,OAAOkD,iBAEPlD,OAAOmD,WAEPnD,OAAOoD,YAET,OAAOJ,GAAY,IAAIA,EAASF,GAGlC,SAASO,EAAKvB,EAAKwB,EAASxI,GAC1B,GAAIgH,EAAK,CACP,IAAIyB,EAAOzB,EAAI0B,qBAAqBF,GAClCtN,EAAI,EACJyN,EAAIF,EAAK7M,OAEX,GAAIoE,EACF,KAAO9E,EAAIyN,EAAGzN,IACZ8E,EAASyI,EAAKvN,GAAIA,GAItB,OAAOuN,EAGT,MAAO,GAGT,SAASG,IAGP,OAFuB/B,SAASgC,kBAKvBhC,SAASiC,gBAapB,SAASC,EACPhD,EACAiD,EACAC,EACAC,EACAC,GAEA,GAAKpD,EAAGqD,uBAAyBrD,IAAOb,OAAxC,CAEA,IAAImE,EAAQC,EAAKC,EAAMC,EAAQC,EAAOC,EAAQC,EAmB9C,GAjBI5D,IAAOb,QAAUa,IAAO6C,KAE1BU,GADAD,EAAStD,EAAGqD,yBACCE,IACbC,EAAOF,EAAOE,KACdC,EAASH,EAAOG,OAChBC,EAAQJ,EAAOI,MACfC,EAASL,EAAOK,OAChBC,EAAQN,EAAOM,QAEfL,EAAM,EACNC,EAAO,EACPC,EAAStE,OAAO0E,YAChBH,EAAQvE,OAAO2E,WACfH,EAASxE,OAAO0E,YAChBD,EAAQzE,OAAO2E,aAIdb,GAA6BC,IAC9BlD,IAAOb,SAGPiE,EAAYA,GAAapD,EAAGlC,YAIvBwB,GACH,GACE,GACE8D,GACAA,EAAUC,wBAEuB,SAAhC5B,EAAI2B,EAAW,cACbF,GAEgC,WAA/BzB,EAAI2B,EAAW,aACnB,CACA,IAAIW,EAAgBX,EAAUC,wBAG9BE,GAEEQ,EAAcR,IAAMS,SAASvC,EAAI2B,EAAW,qBAC9CI,GAEEO,EAAcP,KAAOQ,SAASvC,EAAI2B,EAAW,sBAC/CK,EAASF,EAAMD,EAAOK,OACtBD,EAAQF,EAAOF,EAAOM,MAEtB,aAGMR,EAAYA,EAAUtF,YAIpC,GAAIqF,GAAanD,IAAOb,OAAQ,CAG9B,IAAI8E,EAAWlC,EAAOqB,GAAapD,GACjCkE,EAASD,GAAYA,EAASE,EAC9BC,EAASH,GAAYA,EAASI,EAE5BJ,IAOFR,GANAF,GAAOa,IAIPT,GAAUS,GAGVV,GANAF,GAAQU,IAERN,GAASM,IAQb,MAAO,CACLX,IAAKA,EACLC,KAAMA,EACNC,OAAQA,EACRC,MAAOA,EACPE,MAAOA,EACPD,OAAQA,IAWZ,SAASW,EAAetE,EAAIuE,EAAQC,GAMlC,IALA,IAAIC,EAASC,EAA2B1E,MAEtC2E,EAAY3B,EAAQhD,GAAIuE,GAGnBE,GAAQ,CAEb,IAAIG,EAAgB5B,EAAQyB,GAAQD,GASpC,KANmB,QAAfA,GAAuC,SAAfA,EAChBG,GAAaC,EAEbD,GAAaC,GAGX,OAAOH,EAErB,GAAIA,IAAW5B,IAA6B,MAE5C4B,EAASC,EAA2BD,MAGtC,SAWF,SAASI,EAAS7E,EAAI8E,EAAUpI,GAK9B,IAJA,IAAIqI,EAAe,EACjB5P,EAAI,EACJ6B,EAAWgJ,EAAGhJ,SAET7B,EAAI6B,EAASnB,QAAQ,CAC1B,GACgC,SAA9BmB,EAAS7B,GAAG4J,MAAMiG,SAElBhO,EAAS7B,KAAOsC,GAASwN,OAEzBjO,EAAS7B,KAAOsC,GAASyN,SACzBlE,EAAQhK,EAAS7B,GAAIuH,EAAQyI,UAAWnF,MACxC,CACA,GAAI+E,IAAiBD,EACnB,OAAO9N,EAAS7B,GAElB4P,IAGF5P,IAEF,YASF,SAASiQ,EAAUpF,EAAIO,GAGrB,IAFA,IAAI8E,EAAOrF,EAAGsF,iBAGZD,IAECA,IAAS5N,GAASwN,OAEQ,SAAzBxD,EAAI4D,EAAM,YACT9E,IAAaD,EAAQ+E,EAAM9E,KAE9B8E,EAAOA,EAAKE,uBAGd,OAAOF,GAAQ,KAUjB,SAASG,EAAMxF,EAAIO,GACjB,IAAIiF,EAAQ,EAEZ,IAAKxF,IAAOA,EAAGlC,WACb,OAAQ,EAIV,KAAQkC,EAAKA,EAAGuF,wBAEkB,aAA9BvF,EAAGyF,SAASC,eAEZ1F,IAAOvI,GAASkO,OACdpF,IAAYD,EAAQN,EAAIO,IAE1BiF,IAIJ,OAAOA,EAST,SAASI,EAAwB5F,GAC/B,IAAI6F,EAAa,EACfC,EAAY,EACZC,EAAclD,IAEhB,GAAI7C,EACF,EAAG,CAED,IAAIiE,EAAWlC,EAAO/B,GAItB6F,GAAc7F,EAAGgG,WAHN/B,EAASE,EAIpB2B,GAAa9F,EAAGiG,UAHLhC,EAASI,QAIbrE,IAAO+F,IAAgB/F,EAAKA,EAAGlC,aAG1C,MAAO,CAAC+H,EAAYC,GAmBtB,SAASpB,EAA2B1E,EAAIkG,GAEtC,IAAKlG,IAAOA,EAAGqD,sBAAuB,OAAOR,IAE7C,IAAIsD,EAAOnG,EACPoG,KACJ,GAEE,GACED,EAAKE,YAAcF,EAAKG,aACxBH,EAAKI,aAAeJ,EAAKK,aACzB,CAEA,IAAIC,EAAUhF,EAAI0E,GAClB,GACGA,EAAKE,YAAcF,EAAKG,cACD,QAArBG,EAAQC,WAA4C,UAArBD,EAAQC,YACzCP,EAAKI,aAAeJ,EAAKK,eACF,QAArBC,EAAQE,WAA4C,UAArBF,EAAQE,WAC1C,CACA,IAAKR,EAAK9C,uBAAyB8C,IAASrF,SAAStK,KACnD,OAAOqM,IAET,GAAIuD,GAAWF,EAAa,OAAOC,EACnCC,aAIID,EAAOA,EAAKrI,YAEtB,OAAO+E,IAeT,SAAS+D,EAAYC,EAAOC,GAC1B,OACEC,KAAKC,MAAMH,EAAMtD,OAASwD,KAAKC,MAAMF,EAAMvD,MAC3CwD,KAAKC,MAAMH,EAAMrD,QAAUuD,KAAKC,MAAMF,EAAMtD,OAC5CuD,KAAKC,MAAMH,EAAMlD,UAAYoD,KAAKC,MAAMF,EAAMnD,SAC9CoD,KAAKC,MAAMH,EAAMjD,SAAWmD,KAAKC,MAAMF,EAAMlD,OAKjD,SAASqD,EAASC,EAAUC,GAC1B,kBACE,IAAKhG,EAAkB,CACrB,IAAIpF,EAAO5C,UACT0C,EAAQvC,KAEU,IAAhByC,EAAKlG,OACPqR,EAASxO,KAAKmD,EAAOE,EAAK,IAE1BmL,EAAS7N,MAAMwC,EAAOE,GAGxBoF,EAAmB1C,YAAW,WAC5B0C,WACCgG,KAUT,SAASC,EAASpH,EAAIqH,EAAGC,GACvBtH,EAAGgG,YAAcqB,EACjBrH,EAAGiG,WAAaqB,EAGlB,SAAS3B,EAAM3F,GAEb,IAAIuH,EAAUpI,OAAOoI,QAEjBC,EAAIrI,OAAOsI,QAAUtI,OAAOuI,MAEhC,OAAIH,GAAWA,EAAQI,IACdJ,EAAQI,IAAI3H,GAAI4H,cACdJ,EACFA,EAAExH,GAAI2F,UAAY,GAElB3F,EAAG4H,cAId,SAASC,EAAQ7H,EAAI8H,GACnBrG,EAAIzB,EAAI,WAAY,YACpByB,EAAIzB,EAAI,MAAO8H,EAAKvE,KACpB9B,EAAIzB,EAAI,OAAQ8H,EAAKtE,MACrB/B,EAAIzB,EAAI,QAAS8H,EAAKlE,OACtBnC,EAAIzB,EAAI,SAAU8H,EAAKnE,QAGzB,SAASoE,EAAU/H,GACjByB,EAAIzB,EAAI,WAAY,IACpByB,EAAIzB,EAAI,MAAO,IACfyB,EAAIzB,EAAI,OAAQ,IAChByB,EAAIzB,EAAI,QAAS,IACjByB,EAAIzB,EAAI,SAAU,IAGpB,IAAMgI,EAAU,YAAa,IAAIC,MAAOC,UCpiBpCC,EAAU,GAERC,EAAW,CACfC,wBAGIC,EAAgB,CACpBC,eAAMC,GAEJ,IAAK,IAAIC,KAAUL,EACbA,EAAS3P,eAAegQ,MAAaA,KAAUD,KACjDA,EAAOC,GAAUL,EAASK,IAG9BN,EAAQ1S,KAAK+S,IAEfE,qBAAYC,EAAWlL,EAAUL,cAC/B9D,KAAKsP,iBACLxL,EAAIyL,OAAS,WACXhN,EAAK+M,kBAEP,IAAME,EAAkBH,EAAY,SACpCR,EAAQjT,SAAQ,SAACsT,GACV/K,EAAS+K,EAAOO,cAEjBtL,EAAS+K,EAAOO,YAAYD,IAC9BrL,EAAS+K,EAAOO,YAAYD,MAAmBrL,YAAaL,IAM5DK,EAASf,QAAQ8L,EAAOO,aACxBtL,EAAS+K,EAAOO,YAAYJ,IAE5BlL,EAAS+K,EAAOO,YAAYJ,MAAalL,YAAaL,SAI5D4L,2BAAkBvL,EAAUuC,EAAIoI,EAAU1L,GAcxC,IAAK,IAAI+L,KAbTN,EAAQjT,SAAQ,SAACsT,GACf,IAAMO,EAAaP,EAAOO,WAC1B,GAAKtL,EAASf,QAAQqM,IAAgBP,EAAOH,oBAA7C,CAEA,IAAIY,EAAc,IAAIT,EAAO/K,EAAUuC,EAAIvC,EAASf,SACpDuM,EAAYxL,SAAWA,EACvBwL,EAAYvM,QAAUe,EAASf,QAC/Be,EAASsL,GAAcE,EAGvBnR,OAAOmB,OAAOmP,EAAUa,EAAYb,cAGnB3K,EAASf,QAC1B,GAAKe,EAASf,QAAQjE,eAAegQ,GAArC,CACA,IAAIS,EAAW5P,KAAK6P,aAClB1L,EACAgL,EACAhL,EAASf,QAAQ+L,aAERS,IACTzL,EAASf,QAAQ+L,GAAUS,KAIjCE,4BAAmBrM,EAAMU,GACvB,IAAI4L,EAAkB,GAStB,OARAlB,EAAQjT,SAAQ,SAACsT,GACuB,mBAA3BA,EAAOa,iBAClBvR,OAAOmB,OACLoQ,EACAb,EAAOa,gBAAgB3Q,KAAK+E,EAAS+K,EAAOO,YAAahM,OAItDsM,GAETF,sBAAa1L,EAAUV,EAAM/E,GAC3B,IAAIsR,EAiBJ,OAhBAnB,EAAQjT,SAAQ,SAACsT,GAEV/K,EAAS+K,EAAOO,aAInBP,EAAOe,iBACiC,mBAAjCf,EAAOe,gBAAgBxM,KAE9BuM,EAAgBd,EAAOe,gBAAgBxM,GAAMrE,KAC3C+E,EAAS+K,EAAOO,YAChB/Q,OAKCsR,aC5FaE,SACtB/L,aACAgM,WACA1M,SACA2M,aACAC,YACAC,SACAC,WACAC,aACAC,aACAC,sBACAC,sBACA1L,kBACA2L,gBACAC,yBAGA,GADA1M,EAAWA,GAAagM,GAAUA,EAAOzB,GACzC,CAEA,IAAI5K,EACFV,EAAUe,EAASf,QACnB0N,EAAS,KAAOrN,EAAKsN,OAAO,GAAG3E,cAAgB3I,EAAKuN,OAAO,IAEzDnL,OAAOoL,aAAgBjL,GAAeC,GAMxCnC,EAAM0D,SAAS0J,YAAY,UACvBC,UAAU1N,MAAM,GANpBK,EAAM,IAAImN,YAAYxN,EAAM,CAC1B2N,WACAC,gBAOJvN,EAAIwN,GAAKhB,GAAQH,EACjBrM,EAAIW,KAAO8L,GAAUJ,EACrBrM,EAAIC,KAAOqM,GAAYD,EACvBrM,EAAIuI,MAAQgE,EAEZvM,EAAI0M,SAAWA,EACf1M,EAAI2M,SAAWA,EAEf3M,EAAI4M,kBAAoBA,EACxB5M,EAAI6M,kBAAoBA,EAExB7M,EAAImB,cAAgBA,EACpBnB,EAAIyN,SAAWX,EAAcA,EAAYY,mBAEzC,IAAIC,OACCZ,EACAa,EAAc5B,mBAAmBrM,EAAMU,IAE5C,IAAK,IAAIgL,KAAUsC,EACjB3N,EAAIqL,GAAUsC,EAAmBtC,GAG/BgB,GACFA,EAAOD,cAAcpM,GAGnBV,EAAQ0N,IACV1N,EAAQ0N,GAAQ1R,KAAK+E,EAAUL,IC5BnC,IAAIsL,EAAc,SAChBC,EACAlL,sBAEkC,KAA3Bc,IAALnB,IAAuB6N,gJAEzBD,EAActC,YAAYwC,KAA1BF,IAAyCrC,EAAWlL,KAClD0N,SACAC,WACAC,UACA5B,SACA6B,SACAC,aACA5B,UACA6B,cACAC,YAAaC,GACbxB,eAEAyB,eAAgBlU,GAASH,OACzBiH,gBAEAuL,WACAE,qBACAD,WACAE,qBAEA2B,mBAAoBC,GACpBC,qBAAsBC,GAEtBC,0BACER,MAEFS,yBACET,MAGFU,+BAAsBnP,GACpBoP,EAAe,CAAE1O,WAAUV,OAAMwB,oBAGhC0M,KAIP,SAASkB,EAAeC,GACtB5C,KACEU,eACAP,UACAD,SAAUyB,EACV1B,SACAK,WACAE,qBACAD,WACAE,sBACGmC,IAIP,IAAIjB,EACFC,EACAC,EACA5B,EACA6B,EACAC,EACA5B,EACA6B,EACA1B,EACAC,EACAC,GACAC,GACAoC,GACAnC,GAIAoC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAjB,GACAkB,GACAC,GAGAC,GAEAC,GAhBAC,MACAC,MACAC,GAAY,GAUZC,MACAC,MAIAC,GAAmC,GACnCC,MACAC,GAAoB,GAGhBC,GAAqC,oBAAb1M,SAC5B2M,GAA0B/N,EAC1BgO,GAAmBnO,GAAQD,EAAa,WAAa,QAErDqO,GACEH,KACC7N,IACAD,GACD,cAAeoB,SAAS9K,cAAc,OACxC4X,GAA2B,WACzB,GAAKJ,GAAL,CAEA,GAAIlO,EACF,OAAO,EAET,IAAIU,EAAKc,SAAS9K,cAAc,KAEhC,OADAgK,EAAGjB,MAAM8O,QAAU,sBACe,SAA3B7N,EAAGjB,MAAM+O,eARS,GAU3BC,GAAmB,SAAU/N,EAAItD,GAE/B,IAAIsR,EAAQvM,EAAIzB,GACdiO,EACEjK,SAASgK,EAAMpK,OACfI,SAASgK,EAAME,aACflK,SAASgK,EAAMG,cACfnK,SAASgK,EAAMI,iBACfpK,SAASgK,EAAMK,kBACjBC,EAASzJ,EAAS7E,EAAI,EAAGtD,GACzB6R,EAAS1J,EAAS7E,EAAI,EAAGtD,GAEzB8R,EAAgBF,GAAU7M,EAAI6M,GAE9BG,EAAiBF,GAAU9M,EAAI8M,GAC/BG,EACEF,GACAxK,SAASwK,EAAcG,YACrB3K,SAASwK,EAAcI,aAEvB5L,EAAQsL,GAAQ1K,MACpBiL,EACEJ,GACAzK,SAASyK,EAAeE,YACtB3K,SAASyK,EAAeG,aAExB5L,EAAQuL,GAAQ3K,MAEtB,MAAsB,SAAlBoK,EAAMhJ,QACuB,WAAxBgJ,EAAMc,eACa,mBAAxBd,EAAMc,cACJ,WACA,aAGgB,SAAlBd,EAAMhJ,QACDgJ,EAAMe,oBAAoBC,MAAM,KAAKnZ,QAAU,EAClD,WACA,aAGFyY,GAAUE,SAA+C,SAAxBA,SAI5BD,GACqB,SAAzBE,EAAeQ,OACdR,EAAeQ,SAJO,SAAxBT,QAAiC,OAAS,SAMxC,aADA,WAICF,IACsB,UAA1BE,EAAcxJ,SACa,SAA1BwJ,EAAcxJ,SACY,UAA1BwJ,EAAcxJ,SACY,SAA1BwJ,EAAcxJ,SACb0J,GAAmBT,GAAuC,SAA5BD,EAAMN,KACpCa,GAC6B,SAA5BP,EAAMN,KACNgB,EAAkBG,EAAmBZ,GACvC,WACA,cA0CNiB,GAAgB,SAAUxS,GACxB,SAASyS,EAAKnX,EAAOmG,GACnB,gBAAiByM,EAAI7M,EAAMoN,EAAQ/N,GAMjC,GAAa,MAATpF,IAAkBmG,GAJpByM,EAAGlO,QAAQwB,MAAMnB,MACjBgB,EAAKrB,QAAQwB,MAAMnB,MACnB6N,EAAGlO,QAAQwB,MAAMnB,OAASgB,EAAKrB,QAAQwB,MAAMnB,MAK7C,OAAO,EAAP,GACkB,MAAT/E,QAAiBA,EAC1B,OAAO,EAAP,GACSmG,GAAkB,UAAVnG,EACjB,OAAOA,KACmB,mBAAVA,EAChB,OAAOmX,EAAKnX,EAAM4S,EAAI7M,EAAMoN,EAAQ/N,GAA7B+R,GACLvE,EACA7M,EACAoN,EACA/N,GAGF,IAAIgS,GAAcjR,EAAOyM,EAAK7M,GAAMrB,QAAQwB,MAAMnB,KAElD,WACE/E,GACkB,iBAAVA,GAAsBA,IAAUoX,GACvCpX,EAAMqX,MAAQrX,EAAM2B,QAAQyV,IAAe,GAMpD,IAAIlR,EAAQ,GACRoR,EAAgB5S,EAAQwB,MAEvBoR,GAAyC,iBAAjBA,IAC3BA,EAAgB,CAAEvS,KAAMuS,IAI1BpR,EAAMnB,KAAOuS,EAAcvS,KAE3BmB,EAAMqR,UAAYJ,EAAKG,EAAcnR,SAErCD,EAAMsR,SAAWL,EAAKG,EAAcG,KAEpCvR,EAAMwR,YAAcJ,EAAcI,YAElChT,EAAQwB,MAAQA,GAElB2N,GAAsB,YACf+B,IAA2BvC,GAC9B5J,EAAI4J,EAAS,UAAW,SAG5BU,GAAwB,YACjB6B,IAA2BvC,GAC9B5J,EAAI4J,EAAS,UAAW,KAK1BmC,IACF1M,SAASX,iBACP,SACA,SAAU/C,GACR,GAAI6P,GAKF,OAJA7P,EAAIuS,iBACJvS,EAAIwS,iBAAmBxS,EAAIwS,kBAC3BxS,EAAIyS,0BAA4BzS,EAAIyS,2BACpC5C,OAAkB,QAQ1B,IC3UI6C,GD2UAC,GAAgC,SAAU3S,GAC5C,GAAI+N,EAAQ,CAEV,IAAI6E,GAxGkC3I,GAuGtCjK,EAAMA,EAAI6S,QAAU7S,EAAI6S,QAAQ,GAAK7S,GACS8S,QAxGL5I,EAwGclK,EAAI+S,QAtG3DjD,GAAUkD,MAAK,SAAC3S,GAEd,IAAI2H,EAAU3H,GAAd,CAGA,IAAIqK,EAAO9E,EAAQvF,GACjB4S,EAAY5S,EAASuK,GAAStL,QAAQ4T,qBAMxC,OAAID,GAJAhJ,GAAKS,EAAKtE,KAAO6M,GAAahJ,GAAKS,EAAKpE,MAAQ2M,GAEhD/I,GAAKQ,EAAKvE,IAAM8M,GAAa/I,GAAKQ,EAAKrE,OAAS4M,EAG1CE,EAAM9S,aAGX8S,GAwFP,GAAIP,EAAS,CAEX,IAAI/P,EAAQ,GACZ,IAAK,IAAI9K,KAAKiI,EACRA,EAAI3E,eAAetD,KACrB8K,EAAM9K,GAAKiI,EAAIjI,IAInB8K,EAAM/G,OAAS+G,EAAMwJ,OAASuG,EAE9B/P,EAAM0P,sBAEN1P,EAAM2P,uBACNI,EAAQhI,GAASwI,YAAYvQ,IAxHH,IAAUoH,EAAGC,EACrCiJ,GA4HJE,GAAwB,SAAUrT,GAChC+N,GACFA,EAAOrN,WAAWkK,GAAS0I,iBAAiBtT,EAAIlE,SASpD,SAASzB,GAASuI,EAAItD,GACpB,IAAMsD,IAAMA,EAAGe,UAA4B,IAAhBf,EAAGe,SAC5B,KAAM,8CAAgD,GAAG4P,SAASjY,KAChEsH,GAIJ1G,KAAK0G,GAAKA,EACV1G,KAAKoD,QAAUA,EAAU5E,OAAOmB,OAAO,GAAIyD,GAG3CsD,EAAGgI,GAAW1O,KAEd,IElXEsX,EADEC,EFmXAzI,EAAW,CACblK,MAAO,KACP4S,QACAC,YACAvV,MAAO,KACPwV,OAAQ,KACR7L,UAAW,WAAW8L,KAAKjR,EAAGyF,UAAY,MAAQ,KAClDyL,cAAe,EACfC,cACAC,sBAAuB,KACvBC,qBACAC,UAAW,WACT,OAAOvD,GAAiB/N,EAAI1G,KAAKoD,UAEnC6U,WAAY,iBACZC,YAAa,kBACbC,UAAW,gBACXC,OAAQ,SACR9U,OAAQ,KACR+U,mBACAC,UAAW,EACXC,OAAQ,KACRC,QAAS,SAAUC,EAAc5G,GAC/B4G,EAAaD,QAAQ,OAAQ3G,EAAO6G,cAEtCC,cACAC,kBACAC,WAAY,UACZC,MAAO,EACPC,oBACAC,qBACGC,OAAOvO,SAAWuO,OAASpT,QAAQ6E,SAElC7E,OAAOqT,iBACP,KACG,EACPC,iBACAC,cAAe,oBACfC,kBACAC,kBAAmB,EACnBC,eAAgB,CAAExL,EAAG,EAAGC,EAAG,GAC3BwL,oBAEErb,GAASqb,gBAA4B,iBAAkB3T,OACzDmR,qBAAsB,GAOxB,IAAK,IAAIvT,KAHTiO,EAAchC,kBAAkB1P,KAAM0G,EAAIoI,GAGzBA,IACbrL,KAAQL,KAAaA,EAAQK,GAAQqL,EAASrL,IAMlD,IAAK,IAAImD,KAHTgP,GAAcxS,QAIS,MAAjBwD,EAAGmK,OAAO,IAAkC,wBAARnK,KACtC5G,KAAK4G,GAAM5G,KAAK4G,GAAIgL,KAAK5R,OAK7BA,KAAKyZ,iBAAkBrW,EAAQ+V,eAAwB9E,GAEnDrU,KAAKyZ,kBAEPzZ,KAAKoD,QAAQ4V,oBAAsB,GAIjC5V,EAAQoW,eACV/S,EAAGC,EAAI,cAAe1G,KAAK0Z,cAE3BjT,EAAGC,EAAI,YAAa1G,KAAK0Z,aACzBjT,EAAGC,EAAI,aAAc1G,KAAK0Z,cAGxB1Z,KAAKyZ,kBACPhT,EAAGC,EAAI,WAAY1G,MACnByG,EAAGC,EAAI,YAAa1G,OAGtB4T,GAAUzX,KAAK6D,KAAK0G,IAGpBtD,EAAQlB,OACNkB,EAAQlB,MAAM3C,KACdS,KAAKwX,KAAKpU,EAAQlB,MAAM3C,IAAIS,OAAS,IAGvCxB,OAAOmB,OAAOK,MEhdVuX,EAAkB,GAGf,CACLoC,iCACEpC,EAAkB,GACbvX,KAAKoD,QAAQkV,WACH,GAAGsB,MAAMxa,KAAKY,KAAK0G,GAAGhJ,UAE5B9B,SAAQ,SAACie,GAEhB,GAA8B,SAA1B1R,EAAI0R,EAAO,qBAAyBA,EAAxC,CAEAtC,EAAgBpb,KAAK,CACnByD,OAAQia,EAERrL,KAAM9E,EAAQmQ,KAEhB,IAAIC,OAAgBvC,EAAgBA,EAAgBhb,OAAS,GAAGiS,MAGhE,GAAIqL,EAAME,sBAAuB,CAC/B,IAAIC,EAAcvR,EAAOoR,MACrBG,IACFF,EAAS7P,KAAO+P,EAAYC,EAC5BH,EAAS5P,MAAQ8P,EAAYE,GAIjCL,EAAMC,SAAWA,OAIrBK,2BAAkBnS,GAChBuP,EAAgBpb,KAAK6L,IAGvBoS,8BAAqBxa,GACnB2X,EAAgB8C,OLuXtB,SAAuBC,EAAKxb,GAC1B,IAAK,IAAIjD,KAAKye,EACZ,GAAKA,EAAInb,eAAetD,GACxB,IAAK,IAAIoD,KAAOH,EACd,GAAIA,EAAIK,eAAeF,IAAQH,EAAIG,KAASqb,EAAIze,GAAGoD,GAAM,OAAOga,OAAOpd,GAG3E,OAAQ,EAPV,CKvX2C0b,EAAiB,CAAE3X,WAAW,IAGrE2a,oBAAW3M,cACT,IAAK5N,KAAKoD,QAAQkV,UAGhB,OAFAkC,aAAalD,QACW,mBAAb1J,GAAyBA,KAItC,IAAI6M,KACFC,EAAgB,EAElBnD,EAAgB3b,SAAQ,SAACoM,GACnB2S,MAAO,EAET/a,EAASoI,EAAMpI,OACfka,EAAWla,EAAOka,SAElBc,EAASlR,EAAQ9J,GACjBib,EAAejb,EAAOib,aACtBC,EAAalb,EAAOkb,WACpBC,EAAgB/S,EAAMwG,KACtBwM,EAAevS,EAAO7I,MAEpBob,IAEFJ,EAAO3Q,KAAO+Q,EAAaf,EAC3BW,EAAO1Q,MAAQ8Q,EAAad,GAG9Bta,EAAOgb,OAASA,EAEZhb,EAAOma,uBAGPzM,EAAYuN,EAAcD,KACzBtN,EAAYwM,EAAUc,KAEtBG,EAAc9Q,IAAM2Q,EAAO3Q,MACzB8Q,EAAc7Q,KAAO0Q,EAAO1Q,QAC5B4P,EAAS7P,IAAM2Q,EAAO3Q,MAAQ6P,EAAS5P,KAAO0Q,EAAO1Q,QAGxDyQ,EA+FZ,SAA2BI,EAAejB,EAAUc,EAAQxX,GAC1D,OACGqK,KAAKwN,KACJxN,KAAKyN,IAAIpB,EAAS7P,IAAM8Q,EAAc9Q,IAAK,GACzCwD,KAAKyN,IAAIpB,EAAS5P,KAAO6Q,EAAc7Q,KAAM,IAE/CuD,KAAKwN,KACHxN,KAAKyN,IAAIpB,EAAS7P,IAAM2Q,EAAO3Q,IAAK,GAClCwD,KAAKyN,IAAIpB,EAAS5P,KAAO0Q,EAAO1Q,KAAM,IAE5C9G,EAAQkV,UAVZ,CA9FcyC,EACAF,EACAC,EACAvY,EAAKa,UAMNkK,EAAYsN,EAAQd,KACvBla,EAAOib,aAAef,EACtBla,EAAOkb,WAAaF,EAEfD,IACHA,EAAOpY,EAAKa,QAAQkV,WAEtB/V,EAAK4Y,QAAQvb,EAAQmb,EAAeH,EAAQD,IAG1CA,IACFF,KACAC,EAAgBjN,KAAK2N,IAAIV,EAAeC,GACxCH,aAAa5a,EAAOyb,qBACpBzb,EAAOyb,oBAAsBlW,YAAW,WACtCvF,EAAO8a,cAAgB,EACvB9a,EAAOib,aAAe,KACtBjb,EAAOka,SAAW,KAClBla,EAAOkb,WAAa,KACpBlb,EAAOma,sBAAwB,OAC9BY,GACH/a,EAAOma,sBAAwBY,MAInCH,aAAalD,GACRmD,EAGHnD,EAAsBnS,YAAW,WACP,mBAAbyI,GAAyBA,MACnC8M,GAJqB,mBAAb9M,GAAyBA,IAMtC2J,EAAkB,IAGpB4D,iBAAQvb,EAAQ0b,EAAaV,EAAQW,GACnC,GAAIA,EAAU,CACZpT,EAAIvI,EAAQ,aAAc,IAC1BuI,EAAIvI,EAAQ,YAAa,IAEzB,IAAI+K,EAAWlC,EAAOzI,KAAK0G,IAGzB8U,GAAcF,EAAYpR,KAAO0Q,EAAO1Q,OAF/BS,GAAYA,EAASE,GAE6B,GAC3D4Q,GAAcH,EAAYrR,IAAM2Q,EAAO3Q,MAF9BU,GAAYA,EAASI,GAE2B,GAE3DnL,EAAO8b,aAAeF,EACtB5b,EAAO+b,aAAeF,EAEtBtT,EACEvI,EACA,YACA,eAAiB4b,EAAa,MAAQC,EAAa,SAGrDzb,KAAK4b,gBAyBb,SAAiBhc,GACf,OAAOA,EAAOic,YADhB,CAzBuCjc,GAE/BuI,EACEvI,EACA,aACA,aACE2b,EACA,MACCvb,KAAKoD,QAAQmV,OAAS,IAAMvY,KAAKoD,QAAQmV,OAAS,KAEvDpQ,EAAIvI,EAAQ,YAAa,sBACE,iBAApBA,EAAOkc,UAAyBtB,aAAa5a,EAAOkc,UAC3Dlc,EAAOkc,SAAW3W,YAAW,WAC3BgD,EAAIvI,EAAQ,aAAc,IAC1BuI,EAAIvI,EAAQ,YAAa,IACzBA,EAAOkc,YAEPlc,EAAO8b,cACP9b,EAAO+b,gBACNJ,QF2qDX,SAASQ,GACPxL,EACAD,EACAuB,EACAmK,EACA5L,EACA6L,EACAhX,EACAiX,GAEA,IAAIpY,EAGFqY,EAFAhY,EAAWoM,EAAO7B,GAClB0N,EAAWjY,EAASf,QAAQ2Y,OA8B9B,OA3BIlW,OAAOoL,aAAgBjL,GAAeC,GAMxCnC,EAAM0D,SAAS0J,YAAY,UACvBC,UAAU,WAAQ,GANtBrN,EAAM,IAAImN,YAAY,OAAQ,CAC5BG,WACAC,gBAOJvN,EAAIwN,GAAKhB,EACTxM,EAAIW,KAAO8L,EACXzM,EAAI8H,QAAUiG,EACd/N,EAAIuY,YAAcL,EAClBlY,EAAIwY,QAAUlM,GAAYE,EAE1BxM,EAAIyY,YAAcN,GAAcvS,EAAQ4G,GACxCxM,EAAIoY,gBAAkBA,EAEtBpY,EAAImB,cAAgBA,EAEpBsL,EAAOL,cAAcpM,GAEjBsY,IACFD,EAASC,EAAShd,KAAK+E,EAAUL,EAAKmB,IAGjCkX,EAGT,SAASK,GAAkB9V,GACzBA,EAAGmF,aAGL,SAAS4Q,KACPzI,MA2GF,SAAS0I,GAAYhW,GAKnB,IAJA,IAAIiW,EAAMjW,EAAGyC,QAAUzC,EAAG9L,UAAY8L,EAAGkW,IAAMlW,EAAGmW,KAAOnW,EAAGgS,YAC1D7c,EAAI8gB,EAAIpgB,OACRugB,EAAM,EAEDjhB,KACLihB,GAAOH,EAAII,WAAWlhB,GAGxB,OAAOihB,EAAIzF,SAAS,IAetB,SAAS2F,GAAUpW,GACjB,OAAOzB,WAAWyB,EAAI,GAGxB,SAASqW,GAAgBC,GACvB,OAAO1C,aAAa0C,GAzjDtB/e,GAASe,UAA6C,CACpD0B,YAAazC,GAEbiZ,iBAAkB,SAAUxX,GACrBI,KAAK0G,GAAGyW,SAASvd,IAAWA,IAAWI,KAAK0G,KAC/C4M,GAAa,OAIjB8J,cAAe,SAAUtZ,EAAKlE,GAC5B,MAAyC,wBAAtBwD,QAAQ4U,UACvBhY,KAAKoD,QAAQ4U,UAAU5Y,KAAKY,KAAM8D,EAAKlE,EAAQiS,GAC/C7R,KAAKoD,QAAQ4U,WAGnB0B,YAAa,SAAkC5V,GAC7C,GAAKA,EAAIuN,WAAT,CACA,IAAI9O,EAAQvC,KACV0G,EAAK1G,KAAK0G,GACVtD,EAAUpD,KAAKoD,QACfiV,EAAkBjV,EAAQiV,gBAC1BtT,EAAOjB,EAAIiB,KACXsY,EACGvZ,EAAI6S,SAAW7S,EAAI6S,QAAQ,IAC3B7S,EAAIwZ,aAAmC,UAApBxZ,EAAIwZ,aAA2BxZ,EACrDlE,GAAUyd,GAASvZ,GAAKlE,OACxB2d,EACGzZ,EAAIlE,OAAO4d,aACR1Z,EAAI2Z,MAAQ3Z,EAAI2Z,KAAK,IACpB3Z,EAAI4Z,cAAgB5Z,EAAI4Z,eAAe,KAC5C9d,EACF0D,EAASF,EAAQE,OAKnB,GAogDJ,SAAgCqa,GAC9B1J,GAAkB1X,OAAS,EAK3B,IAHA,IAAIqhB,EAASD,EAAKtU,qBAAqB,SACnCwU,EAAMD,EAAOrhB,OAEVshB,KAAO,CACZ,IAAInX,EAAKkX,EAAOC,GAChBnX,EAAGoX,SAAW7J,GAAkB9X,KAAKuK,IARzC,CAvgD2BA,IAGnBmL,KAKD,wBAAwB8F,KAAK5S,IAAwB,IAAfjB,EAAIia,QAC3C3a,EAAQqU,YAMN8F,EAAeS,oBAMhBhe,KAAKyZ,kBACNtT,IACAvG,GACiC,WAAjCA,EAAOuJ,QAAQiD,mBAKjBxM,EAAS8H,EAAQ9H,EAAQwD,EAAQyI,UAAWnF,QAE9B9G,EAAOkc,UAIjB7J,IAAerS,GAAnB,CAWA,GAJA4Q,EAAWtE,EAAMtM,GACjB8Q,GAAoBxE,EAAMtM,EAAQwD,EAAQyI,WAGpB,mBAAXvI,GACT,GAAIA,EAAOlE,KAAKY,KAAM8D,EAAKlE,EAAQI,MAWjC,OAVA6S,EAAe,CACb1O,SAAU5B,EACV4N,OAAQoN,EACR9Z,KAAM,SACN2M,SAAUxQ,EACV0Q,KAAM5J,EACN6J,OAAQ7J,IAEV0I,EAAY,SAAU7M,EAAO,CAAEuB,aAC/BuU,GAAmBvU,EAAIuN,YAAcvN,EAAIuS,0BAGlC/S,IACTA,EAASA,EAAOoS,MAAM,KAAKoB,MAAK,SAAUmH,GAGxC,GAFAA,EAAWvW,EAAQ6V,EAAgBU,EAASC,OAAQxX,MAYlD,OATAmM,EAAe,CACb1O,SAAU5B,EACV4N,OAAQ8N,EACRxa,KAAM,SACN2M,SAAUxQ,EACV2Q,OAAQ7J,EACR4J,KAAM5J,IAER0I,EAAY,SAAU7M,EAAO,CAAEuB,eAOjC,YADAuU,GAAmBvU,EAAIuN,YAAcvN,EAAIuS,kBAKzCjT,EAAQsU,SAAWhQ,EAAQ6V,EAAgBna,EAAQsU,OAAQhR,OAK/D1G,KAAKme,kBAAkBra,EAAKuZ,EAAOzd,MAGrCue,kBAAmB,SACJra,EACAuZ,EACMzd,GAEnB,IAIEwe,EAJE7b,EAAQvC,KACV0G,EAAKnE,EAAMmE,GACXtD,EAAUb,EAAMa,QAChBib,EAAgB3X,EAAG2X,cAGrB,GAAIze,IAAWiS,GAAUjS,EAAO4E,aAAekC,EAAI,CAEjD,IAAIsV,EAAWtS,EAAQ9J,GA4EvB,GA3EAuQ,EAASzJ,EAEToL,GADAD,EAASjS,GACS4E,WAClBwN,EAASH,EAAO1P,YAChB8P,EAAarS,EACbmT,GAAc3P,EAAQwB,MAGtBzG,GAASyN,QAAUiG,EAQnBuB,IANAJ,GAAS,CACPpT,OAAQiS,EACR+E,SAAUyG,GAASvZ,GAAK8S,QACxBC,SAAUwG,GAASvZ,GAAK+S,UAGDD,QAAUoF,EAAS9R,KAC5CmJ,GAAiBL,GAAO6D,QAAUmF,EAAS/R,IAE3CjK,KAAKse,QAAUjB,GAASvZ,GAAK8S,QAC7B5W,KAAKue,QAAUlB,GAASvZ,GAAK+S,QAE7BhF,EAAOpM,MAAM,eAAiB,MAE9B2Y,EAAc,WACZhP,EAAY,aAAc7M,EAAO,CAAEuB,QAE/B3F,GAASmR,cACX/M,EAAMic,WAKRjc,EAAMkc,6BAEDvY,GAAW3D,EAAMkX,kBACpB5H,EAAOhG,cAITtJ,EAAMmc,kBAAkB5a,EAAKuZ,GAG7BxK,EAAe,CACb1O,SAAU5B,EACVkB,KAAM,SACNwB,cAAenB,IAIjBiE,EAAY8J,EAAQzO,EAAQ8U,kBAI9B9U,EAAQgV,OAAO1C,MAAM,KAAK9Z,SAAQ,SAAUqiB,GAC1C/U,EAAK2I,EAAQoM,EAASC,OAAQ1B,OAGhC/V,EAAG4X,EAAe,WAAY5H,IAC9BhQ,EAAG4X,EAAe,YAAa5H,IAC/BhQ,EAAG4X,EAAe,YAAa5H,IAE/BhQ,EAAG4X,EAAe,UAAW9b,EAAMic,SACnC/X,EAAG4X,EAAe,WAAY9b,EAAMic,SACpC/X,EAAG4X,EAAe,cAAe9b,EAAMic,SAGnCtY,GAAWlG,KAAKyZ,kBAClBzZ,KAAKoD,QAAQ4V,oBAAsB,EACnCnH,EAAOhG,cAGTuD,EAAY,aAAcpP,KAAM,CAAE8D,SAIhCV,EAAQ0V,OACN1V,EAAQ2V,mBAAoBsE,GAC5Brd,KAAKyZ,kBAAqBxT,GAAQD,GAoBpCoY,QAnBA,CAEA,GAAIjgB,GAASmR,cAEX,YADAtP,KAAKwe,UAMP/X,EAAG4X,EAAe,UAAW9b,EAAMoc,qBACnClY,EAAG4X,EAAe,WAAY9b,EAAMoc,qBACpClY,EAAG4X,EAAe,cAAe9b,EAAMoc,qBACvClY,EAAG4X,EAAe,YAAa9b,EAAMqc,8BACrCnY,EAAG4X,EAAe,YAAa9b,EAAMqc,8BACrCxb,EAAQoW,gBACN/S,EAAG4X,EAAe,cAAe9b,EAAMqc,8BAEzCrc,EAAMsc,gBAAkB1Z,WAAWiZ,EAAahb,EAAQ0V,UAO9D8F,6BAA8B,SAA0C1E,GACtE,IAAImD,EAAQnD,EAAEvD,QAAUuD,EAAEvD,QAAQ,GAAKuD,EAErCzM,KAAK2N,IACH3N,KAAKqR,IAAIzB,EAAMzG,QAAU5W,KAAKse,QAC9B7Q,KAAKqR,IAAIzB,EAAMxG,QAAU7W,KAAKue,UAEhC9Q,KAAKsR,MACH/e,KAAKoD,QAAQ4V,qBACThZ,KAAKyZ,iBAAmB5T,OAAOqT,kBAAqB,KAG1DlZ,KAAK2e,uBAITA,oBAAqB,WACnB9M,GAAU2K,GAAkB3K,GAC5B2I,aAAaxa,KAAK6e,iBAElB7e,KAAKye,6BAGPA,0BAA2B,WACzB,IAAIJ,EAAgBre,KAAK0G,GAAG2X,cAC5BvX,EAAIuX,EAAe,UAAWre,KAAK2e,qBACnC7X,EAAIuX,EAAe,WAAYre,KAAK2e,qBACpC7X,EAAIuX,EAAe,cAAere,KAAK2e,qBACvC7X,EAAIuX,EAAe,YAAare,KAAK4e,8BACrC9X,EAAIuX,EAAe,YAAare,KAAK4e,8BACrC9X,EAAIuX,EAAe,cAAere,KAAK4e,+BAGzCF,kBAAmB,SAAuB5a,EAAkBuZ,GAC1DA,EAAQA,GAA6B,SAAnBvZ,EAAIwZ,aAA0BxZ,GAE3C9D,KAAKyZ,iBAAmB4D,EAEzB5W,EAAGe,SADDxH,KAAKoD,QAAQoW,eACF,cACJ6D,EACI,YAEA,YAJerd,KAAKgf,eAOnCvY,EAAGoL,EAAQ,UAAW7R,MACtByG,EAAG0J,EAAQ,YAAanQ,KAAKif,eAG/B,IAEMzX,SAAS0X,UAEXlC,IAAU,WAERxV,SAAS0X,UAAUC,WAGrBtZ,OAAOuZ,eAAeC,kBAExB,MAAOC,MAGXC,aAAc,SAAUC,EAAU1b,GAGhC,GAFA4P,MAEIvD,GAAU0B,EAAQ,CACpBzC,EAAY,cAAepP,KAAM,CAAE8D,QAE/B9D,KAAKyZ,iBACPhT,EAAGe,SAAU,WAAY2P,IAE3B,IAAI/T,EAAUpD,KAAKoD,SAGlBoc,GAAYzX,EAAY8J,EAAQzO,EAAQ+U,cACzCpQ,EAAY8J,EAAQzO,EAAQ6U,eAG5B9Z,GAASH,OAASgC,KAElBwf,GAAYxf,KAAKyf,eAGjB5M,EAAe,CACb1O,SAAUnE,KACVyD,KAAM,QACNwB,cAAenB,SAGjB9D,KAAK0f,YAITC,iBAAkB,WAChB,GAAI1M,GAAU,CACZjT,KAAKse,OAASrL,GAAS2D,QACvB5W,KAAKue,OAAStL,GAAS4D,QAEvBtE,KAQA,IANA,IAAI3S,EAAS4H,SAASoY,iBACpB3M,GAAS2D,QACT3D,GAAS4D,SAEP1L,EAASvL,EAENA,GAAUA,EAAO4d,aACtB5d,EAASA,EAAO4d,WAAWoC,iBACzB3M,GAAS2D,QACT3D,GAAS4D,YAEI1L,GACfA,EAASvL,EAKX,GAFAiS,EAAOrN,WAAWkK,GAAS0I,iBAAiBxX,GAExCuL,EACF,EAAG,CACD,GAAIA,EAAOuD,IAGEvD,EAAOuD,GAASwI,YAAY,CACrCN,QAAS3D,GAAS2D,QAClBC,QAAS5D,GAAS4D,QAClBjX,OAAQA,EACRuQ,OAAQhF,MAGOnL,KAAKoD,QAAQwV,eAC5B,MAIJhZ,EAASuL,QAIRA,EAASA,EAAO3G,YAIrBiO,OAIJuM,aAAc,SAA0Blb,GACtC,GAAIkP,GAAQ,CACV,IAAI5P,EAAUpD,KAAKoD,QACjBkW,EAAoBlW,EAAQkW,kBAC5BC,EAAiBnW,EAAQmW,eACzB8D,EAAQvZ,EAAI6S,QAAU7S,EAAI6S,QAAQ,GAAK7S,EACvC+b,EAAc9N,GAAWtJ,EAAOsJ,MAChCnH,EAASmH,GAAW8N,GAAeA,EAAYhV,EAC/CC,EAASiH,GAAW8N,GAAeA,EAAY9U,EAC/C+U,EACE3L,IACAV,IACAnH,EAAwBmH,IAC1BsM,GACG1C,EAAMzG,QAAU5D,GAAO4D,QAAU2C,EAAexL,IAAMnD,GAAU,IAChEkV,EACGA,EAAqB,GAAK/L,GAAiC,GAC3D,IACDnJ,GAAU,GACfoV,GACG3C,EAAMxG,QAAU7D,GAAO6D,QAAU0C,EAAevL,IAAMlD,GAAU,IAChEgV,EACGA,EAAqB,GAAK/L,GAAiC,GAC3D,IACDjJ,GAAU,GAIjB,IAAK3M,GAASH,SAAW0V,GAAqB,CAC5C,GACE4F,GACA7L,KAAK2N,IACH3N,KAAKqR,IAAIzB,EAAMzG,QAAU5W,KAAKse,QAC9B7Q,KAAKqR,IAAIzB,EAAMxG,QAAU7W,KAAKue,SAC5BjF,EAEJ,OAEFtZ,KAAKif,aAAanb,MAGpB,GAAIiO,EAAS,CACP8N,GACFA,EAAY3F,GAAK6F,GAAM7M,IAAU,GACjC2M,EAAY5F,GAAK+F,GAAM7M,IAAU,IAEjC0M,EAAc,CACZhV,EAAG,EACHoV,EAAG,EACHC,EAAG,EACHnV,EAAG,EACHmP,EAAG6F,EACH9F,EAAG+F,GAIP,IAAIG,YAAsBN,EAAYhV,MAAKgV,EAAYI,MAAKJ,EAAYK,MAAKL,EAAY9U,MAAK8U,EAAY3F,MAAK2F,EAAY5F,MAE3H9R,EAAI4J,EAAS,kBAAmBoO,GAChChY,EAAI4J,EAAS,eAAgBoO,GAC7BhY,EAAI4J,EAAS,cAAeoO,GAC5BhY,EAAI4J,EAAS,YAAaoO,GAE1BjN,GAAS6M,EACT5M,GAAS6M,EAET/M,GAAWoK,EAGbvZ,EAAIuN,YAAcvN,EAAIuS,mBAI1BoJ,aAAc,WAGZ,IAAK1N,EAAS,CACZ,IAAIjI,EAAY9J,KAAKoD,QAAQiW,eAAiB7R,SAAStK,KAAOiT,EAC5D3B,EAAO9E,EAAQmI,KAAcsC,MAA+BrK,GAC5D1G,EAAUpD,KAAKoD,QAGjB,GAAI+Q,GAAyB,CAI3B,IAFAV,GAAsB3J,EAIqB,WAAzC3B,EAAIsL,GAAqB,aAEiB,SAA1CtL,EAAIsL,GAAqB,cACzBA,KAAwBjM,UAExBiM,GAAsBA,GAAoBjP,WAI1CiP,KAAwBjM,SAAStK,MACjCuW,KAAwBjM,SAASiC,iBAE7BgK,KAAwBjM,WAC1BiM,GAAsBlK,KAExBiF,EAAKvE,KAAOwJ,GAAoB9G,UAChC6B,EAAKtE,MAAQuJ,GAAoB/G,YAEjC+G,GAAsBlK,IAExBwK,GAAmCzH,EACjCmH,IAMJ1L,EAFAgK,EAAUF,EAAOvD,cAEIlL,EAAQ6U,eAC7BlQ,EAAYgK,EAAS3O,EAAQgW,kBAC7BrR,EAAYgK,EAAS3O,EAAQ+U,cAE7BhQ,EAAI4J,EAAS,aAAc,IAC3B5J,EAAI4J,EAAS,YAAa,IAE1B5J,EAAI4J,EAAS,aAAc,cAC3B5J,EAAI4J,EAAS,SAAU,GACvB5J,EAAI4J,EAAS,MAAOvD,EAAKvE,KACzB9B,EAAI4J,EAAS,OAAQvD,EAAKtE,MAC1B/B,EAAI4J,EAAS,QAASvD,EAAKlE,OAC3BnC,EAAI4J,EAAS,SAAUvD,EAAKnE,QAC5BlC,EAAI4J,EAAS,UAAW,OACxB5J,EAAI4J,EAAS,WAAYoC,GAA0B,WAAa,SAChEhM,EAAI4J,EAAS,SAAU,UACvB5J,EAAI4J,EAAS,gBAAiB,QAG9B5T,GAASwN,MAAQoG,EAEjBjI,EAAUsW,YAAYrO,GAGtB5J,EACE4J,EACA,mBACCqB,GAAkB1I,SAASqH,EAAQtM,MAAM6E,OAAU,IAClD,KACC+I,GAAiB3I,SAASqH,EAAQtM,MAAM4E,QAAW,IACpD,OAKR4U,aAAc,SAAqBnb,EAAkB0b,GACnD,IAAIjd,EAAQvC,KACRyY,EAAe3U,EAAI2U,aACnBrV,EAAUb,EAAMa,QAEpBgM,EAAY,YAAapP,KAAM,CAAE8D,QAE7B3F,GAASmR,cACXtP,KAAKwe,WAIPpP,EAAY,aAAcpP,MAErB7B,GAASmR,iBACZe,EAAUhE,EAAMwF,IAERhG,aACRwE,EAAQ5K,MAAM,eAAiB,GAE/BzF,KAAKqgB,aAELtY,EAAYsI,EAASrQ,KAAKoD,QAAQ8U,gBAElC/Z,GAASkO,MAAQgE,GAInB9N,EAAM+d,QAAUtD,IAAU,WACxB5N,EAAY,QAAS7M,GAEjBpE,GAASmR,gBAER/M,EAAMa,QAAQ2U,mBACjB5H,EAAOzL,aAAa2L,EAASwB,GAE/BtP,EAAM8d,aAENxN,EAAe,CACb1O,SAAU5B,EACVkB,KAAM,eAIT+b,GAAYzX,EAAY8J,EAAQzO,EAAQ+U,cAGrCqH,GACF7L,MACApR,EAAMge,QAAUC,YAAYje,EAAMod,iBAAkB,MAGpD7Y,EAAIU,SAAU,UAAWjF,EAAMic,SAC/B1X,EAAIU,SAAU,WAAYjF,EAAMic,SAChC1X,EAAIU,SAAU,cAAejF,EAAMic,SAE/B/F,IACFA,EAAagI,cAAgB,OAC7Brd,EAAQoV,SAAWpV,EAAQoV,QAAQpZ,KAAKmD,EAAOkW,EAAc5G,IAG/DpL,EAAGe,SAAU,OAAQjF,GAGrB4F,EAAI0J,EAAQ,YAAa,kBAG3B6B,MAEAnR,EAAMme,aAAe1D,GACnBza,EAAMgd,aAAa3N,KAAKrP,EAAOid,EAAU1b,IAE3C2C,EAAGe,SAAU,cAAejF,GAE5B6P,MAEIjM,GACFgC,EAAIX,SAAStK,KAAM,cAAe,UAKtCga,YAAa,SAAqBpT,GAChC,IAEEkY,EACAC,EACA0E,EAQAC,EAZEla,EAAK1G,KAAK0G,GACZ9G,EAASkE,EAAIlE,OAIbwD,EAAUpD,KAAKoD,QACfwB,EAAQxB,EAAQwB,MAEhByN,EAAiBlU,GAASH,OAC1B6iB,EAAU9N,KAAgBnO,EAC1Bkc,EAAU1d,EAAQoU,KAClBuJ,EAAenQ,IAAeyB,EAE9B9P,EAAQvC,KACRghB,KAEF,IAAIhN,GAAJ,CAuIA,YATIlQ,EAAIuS,gBACNvS,EAAIuN,YAAcvN,EAAIuS,iBAGxBzW,EAAS8H,EAAQ9H,EAAQwD,EAAQyI,UAAWnF,MAG5Cua,EAAc,YAEV9iB,GAASmR,cAAe,OAAO0R,EAEnC,GACEnP,EAAOsL,SAASrZ,EAAIlE,SACnBA,EAAOkc,UAAYlc,EAAO8b,YAAc9b,EAAO+b,YAChDpZ,EAAM2e,wBAA0BthB,EAEhC,OAAOuhB,MAKT,GAFAxN,MAGEtB,IACCjP,EAAQqU,WACRoJ,EACGC,IAAYH,GAAUxQ,EAAOgN,SAAStL,IACtCjB,KAAgB5Q,OACdA,KAAKwR,YAAcuB,GAAYkD,UAC/BjW,KACAqS,EACAR,EACA/N,KAEAc,EAAMsR,SAASlW,KAAMqS,EAAgBR,EAAQ/N,IACnD,CASA,GARA8c,EAA+C,aAApC5gB,KAAKod,cAActZ,EAAKlE,GAGnCoc,EAAWtS,EAAQmI,GAGnBoP,EAAc,iBAEV9iB,GAASmR,cAAe,OAAO0R,EAEnC,GAAIL,EAkBF,OAjBA7O,EAAW3B,EACX5J,IAEAvG,KAAKqgB,aAGLY,EAAc,UAGT9iB,GAASmR,gBACR0C,EACF7B,EAAOzL,aAAamN,EAAQG,GAE5B7B,EAAOiQ,YAAYvO,IAIhBsP,MAGT,IAAIC,EAActV,EAAUpF,EAAItD,EAAQyI,WAExC,IACGuV,GAmnBT,SAAsBtd,EAAK8c,EAAUzc,GAEnC,IAAIqK,EAAO9E,EAAQoC,EAAU3H,EAASuC,GAAIvC,EAASf,QAAQyI,YAG3D,OAAO+U,EACH9c,EAAI8S,QAAUpI,EAAKpE,MAHR,IAIRtG,EAAI8S,SAAWpI,EAAKpE,OACnBtG,EAAI+S,QAAUrI,EAAKrE,QACnBrG,EAAI8S,SAAWpI,EAAKtE,KACvBpG,EAAI8S,QAAUpI,EAAKpE,OAAStG,EAAI+S,QAAUrI,EAAKvE,KAC7CnG,EAAI8S,SAAWpI,EAAKpE,OAAStG,EAAI+S,QAAUrI,EAAKrE,OARxC,GAHjB,CAlnBsBrG,EAAK8c,EAAU5gB,QAAUohB,EAAYtF,SACnD,CAEA,GAAIsF,IAAgBvP,EAClB,OAAOsP,MAaT,GATIC,GAAe1a,IAAO5C,EAAIlE,SAC5BA,EAASwhB,GAGPxhB,IAEFqc,EAAavS,EAAQ9J,SAIrBmc,GACE5L,EACAzJ,EACAmL,EACAmK,EACApc,EACAqc,EACAnY,IACElE,GAQJ,OALA2G,IACAG,EAAG0Z,YAAYvO,GACfC,EAAWpL,EAEX2a,IACOF,WAAU,GAEVvhB,EAAO4E,aAAekC,EAAI,CAEnCuV,EAAavS,EAAQ9J,GACrB,IAAIoY,EACFsJ,EAiCEC,EAhCFC,EAAiB3P,EAAOrN,aAAekC,EACvC+a,GArnCa,SAAUzF,EAAUC,EAAY2E,GACnD,IAAIc,EAAcd,EAAW5E,EAAS9R,KAAO8R,EAAS/R,IAGpD0X,EAAcf,EAAW3E,EAAW/R,KAAO+R,EAAWhS,IAIxD,OACEyX,IAAgBC,IAPFf,EAAW5E,EAAS5R,MAAQ4R,EAAS7R,WAGrCyW,EAAW3E,EAAW7R,MAAQ6R,EAAW9R,SAMvDuX,GARkBd,EAAW5E,EAAS1R,MAAQ0R,EAAS3R,QAQvB,IAAMsX,GALpBf,EAAW3E,EAAW3R,MAAQ2R,EAAW5R,QAKW,EAXrD,CAsnCVwH,EAAOiK,UAAYjK,EAAO+I,QAAWoB,EACrCpc,EAAOkc,UAAYlc,EAAOgb,QAAWqB,EACtC2E,GAEFgB,EAAQhB,EAAW,MAAQ,OAC3BiB,EACE7W,EAAepL,EAAQ,MAAO,QAC9BoL,EAAe6G,EAAQ,MAAO,OAChCiQ,EAAeD,EAAkBA,EAAgBlV,iBAwBnD,GAtBI2G,KAAe1T,IACjB0hB,EAAwBrF,EAAW2F,GACnC/N,MACAC,IACI2N,GAAmBre,EAAQyU,YAAe2J,GAkB9B,KAflBxJ,EAokBR,SACElU,EACAlE,EACAqc,EACA2E,EACAhJ,EACAE,EACAD,EACAkK,GAEA,IAAIC,EAAcpB,EAAW9c,EAAI+S,QAAU/S,EAAI8S,QAC7CqL,EAAerB,EAAW3E,EAAW5R,OAAS4R,EAAW3R,MACzD4X,EAAWtB,EAAW3E,EAAWhS,IAAMgS,EAAW/R,KAClDiY,EAAWvB,EAAW3E,EAAW9R,OAAS8R,EAAW7R,MACrDgY,KAEF,IAAKvK,EAEH,GAAIkK,GAAgBvO,GAAqByO,EAAerK,GAatD,IATG/D,KACkB,IAAlBN,GACGyO,EAAcE,EAAYD,EAAenK,EAAyB,EAClEkK,EAAcG,EAAYF,EAAenK,EAAyB,KAGtEjE,OAGGA,GAUHuO,UARA,GACoB,IAAlB7O,GACIyO,EAAcE,EAAW1O,GACzBwO,EAAcG,EAAW3O,GAE7B,OAAQD,QAOZ,GACEyO,EAAcE,EAAYD,GAAgB,EAAIrK,GAAkB,GAChEoK,EAAcG,EAAYF,GAAgB,EAAIrK,GAAkB,EAEhE,OA0BR,SAA6BhY,GAE3B,OAAIsM,EAAM2F,GAAU3F,EAAMtM,MAGhB,EALZ,CA1BmCA,GAOjC,OAFAwiB,EAASA,GAAUvK,KAKfmK,EAAcE,EAAYD,EAAenK,EAAyB,GAClEkK,EAAcG,EAAYF,EAAenK,EAAyB,GAE3DkK,EAAcE,EAAWD,EAAe,EAAI,GAAK,IA9D9D,CAnkBUne,EACAlE,EACAqc,EACA2E,EACAa,EAAkB,EAAIre,EAAQwU,cACG,MAAjCxU,EAAQ0U,sBACJ1U,EAAQwU,cACRxU,EAAQ0U,sBACZhE,GACAR,KAAe1T,IAKI,CAGnB,IAAIyiB,EAAYnW,EAAM2F,GAEtB,GAEE0P,EAAUzP,EAASpU,SADnB2kB,GAAarK,SAGbuJ,IAE6B,SAA5BpZ,EAAIoZ,EAAS,YAAyBA,IAAYxP,IAIvD,GAAkB,IAAdiG,GAAmBuJ,IAAY3hB,EACjC,OAAOuhB,MAGT7N,GAAa1T,EAEb2T,GAAgByE,EAEhB,IAAI7V,EAAcvC,EAAOoE,mBACvBse,KAIEC,EAAaxG,GACf5L,EACAzJ,EACAmL,EACAmK,EACApc,EACAqc,EACAnY,EATFwe,EAAsB,IAAdtK,GAaR,QAAIuK,EAuCF,OAtCmB,IAAfA,IAAoC,IAAhBA,IACtBD,EAAuB,IAAfC,GAGVvO,MACA7O,WAAWsX,GAAW,IAEtBlW,IAEI+b,IAAUngB,EACZuE,EAAG0Z,YAAYvO,GAEfjS,EAAO4E,WAAWE,aAChBmN,EACAyQ,EAAQngB,EAAcvC,GAKtBiiB,GACF/T,EACE+T,EACA,EACAC,EAAeD,EAAgBlV,WAInCmF,EAAWD,EAAOrN,oBAGd8c,GAAwCxN,KAC1CN,GAAqB/F,KAAKqR,IAExBwC,EAAwB5X,EAAQ9J,GAAQgiB,KAG5CP,IAEOF,MAIX,GAAIza,EAAGyW,SAAStL,GACd,OAAOsP,MAIX,SApWA,SAASF,EAAcxd,EAAM+e,GAC3BpT,EAAY3L,EAAMlB,KAChBuB,MACA+c,UACA4B,KAAM7B,EAAW,WAAa,aAC9BD,SACA3E,WACAC,aACA6E,UACAC,eACAnhB,SACAuhB,YACApF,gBAAOnc,EAAQ0iB,GACb,OAAOvG,GACL5L,EACAzJ,EACAmL,EACAmK,EACApc,EAEA8J,EAAQ9J,GACRkE,EACAwe,IAGJjB,WACGmB,IAKP,SAASjc,IAEP0a,EAAc,4BAEd1e,EAAMoX,wBACFpX,IAAUwe,GACZA,EAAapH,wBAKjB,SAASwH,EAAUuB,GAgEjB,OA/DAzB,EAAc,oBAAqB,CAAEyB,cAEjCA,IAEE7B,EACFxO,EAAegO,aAEfhO,EAAesQ,WAAWpgB,GAGxBA,IAAUwe,IAEZhZ,EACE8J,EACAjB,GACIA,GAAYxN,QAAQ6U,WACpB5F,EAAejP,QAAQ6U,eAG7BlQ,EAAY8J,EAAQzO,EAAQ6U,gBAI1BrH,KAAgBrO,GAASA,IAAUpE,GAASH,OAC9C4S,GAAcrO,EAELA,IAAUpE,GAASH,QAAU4S,KACtCA,GAAc,MAIZmQ,IAAiBxe,IACnBA,EAAM2e,sBAAwBthB,GAEhC2C,EAAMgY,YAAW,WAEf0G,EAAc,6BACd1e,EAAM2e,sBAAwB,QAE5B3e,IAAUwe,IACZA,EAAaxG,aACbwG,EAAaG,sBAAwB,QAMtCthB,IAAWiS,IAAWA,EAAOiK,UAC7Blc,IAAW8G,IAAO9G,EAAOkc,YAE1BxI,GAAa,MAIVlQ,EAAQwV,gBAAmB9U,EAAIqM,QAAUvQ,IAAW4H,WACvDqK,EAAOrN,WAAWkK,GAAS0I,iBAAiBtT,EAAIlE,SAG/C8iB,GAAajM,GAA8B3S,KAG7CV,EAAQwV,gBAAkB9U,EAAIwS,iBAAmBxS,EAAIwS,kBAE9C0K,KAIV,SAASK,IAEP5Q,EAAWvE,EAAM2F,GACjBlB,GAAoBzE,EAAM2F,EAAQzO,EAAQyI,WAC1CgH,EAAe,CACb1O,SAAU5B,EACVkB,KAAM,SACN6M,KAAM5J,EACN+J,WACAE,qBACA1L,cAAenB,MA+OrBod,sBAAuB,KAEvB0B,eAAgB,WACd9b,EAAIU,SAAU,YAAaxH,KAAKgf,cAChClY,EAAIU,SAAU,YAAaxH,KAAKgf,cAChClY,EAAIU,SAAU,cAAexH,KAAKgf,cAClClY,EAAIU,SAAU,WAAYiP,IAC1B3P,EAAIU,SAAU,YAAaiP,IAC3B3P,EAAIU,SAAU,YAAaiP,KAG7BoM,aAAc,WACZ,IAAIxE,EAAgBre,KAAK0G,GAAG2X,cAE5BvX,EAAIuX,EAAe,UAAWre,KAAKwe,SACnC1X,EAAIuX,EAAe,WAAYre,KAAKwe,SACpC1X,EAAIuX,EAAe,YAAare,KAAKwe,SACrC1X,EAAIuX,EAAe,cAAere,KAAKwe,SACvC1X,EAAIU,SAAU,cAAexH,OAG/Bwe,QAAS,SAAqB1a,GAC5B,IAAI4C,EAAK1G,KAAK0G,GACZtD,EAAUpD,KAAKoD,QAIjBqN,EAAWvE,EAAM2F,GACjBlB,GAAoBzE,EAAM2F,EAAQzO,EAAQyI,WAE1CuD,EAAY,OAAQpP,KAAM,CACxB8D,QAGFgO,EAAWD,GAAUA,EAAOrN,WAI5BiM,EAAWvE,EAAM2F,GACjBlB,GAAoBzE,EAAM2F,EAAQzO,EAAQyI,WAGtC1N,GAASmR,gBAKboE,MACAI,MACAD,MAEAiP,cAAc9iB,KAAKugB,SAEnB/F,aAAaxa,KAAK6e,iBAElB5B,GAAgBjd,KAAKsgB,SACrBrD,GAAgBjd,KAAK0gB,cAGjB1gB,KAAKyZ,kBACP3S,EAAIU,SAAU,OAAQxH,MACtB8G,EAAIJ,EAAI,YAAa1G,KAAKif,eAE5Bjf,KAAK4iB,iBACL5iB,KAAK6iB,eAED1c,GACFgC,EAAIX,SAAStK,KAAM,cAAe,IAGpCiL,EAAI0J,EAAQ,YAAa,IAErB/N,IACEsO,KACFtO,EAAIuN,YAAcvN,EAAIuS,kBACrBjT,EAAQuV,YAAc7U,EAAIwS,mBAG7BvE,GAAWA,EAAQvN,YAAcuN,EAAQvN,WAAWM,YAAYiN,IAG9D5B,IAAW2B,GACVlB,IAA2C,UAA5BA,GAAYY,cAG5BnB,GACEA,EAAQ7L,YACR6L,EAAQ7L,WAAWM,YAAYuL,GAG/BwB,IACE7R,KAAKyZ,iBACP3S,EAAI+K,EAAQ,UAAW7R,MAGzBwc,GAAkB3K,GAClBA,EAAOpM,MAAM,eAAiB,GAI1B2M,KAAUsB,IACZ3L,EACE8J,EACAjB,GACIA,GAAYxN,QAAQ6U,WACpBjY,KAAKoD,QAAQ6U,eAIrBlQ,EAAY8J,EAAQ7R,KAAKoD,QAAQ8U,gBAGjCrF,EAAe,CACb1O,SAAUnE,KACVyD,KAAM,WACN6M,KAAMwB,EACNrB,SAAU,KACVE,kBAAmB,KACnB1L,cAAenB,IAGbqM,IAAW2B,GACTrB,GAAY,IAEdoC,EAAe,CACb1C,OAAQ2B,EACRrO,KAAM,MACN6M,KAAMwB,EACNvB,OAAQJ,EACRlL,cAAenB,IAIjB+O,EAAe,CACb1O,SAAUnE,KACVyD,KAAM,SACN6M,KAAMwB,EACN7M,cAAenB,IAIjB+O,EAAe,CACb1C,OAAQ2B,EACRrO,KAAM,OACN6M,KAAMwB,EACNvB,OAAQJ,EACRlL,cAAenB,IAGjB+O,EAAe,CACb1O,SAAUnE,KACVyD,KAAM,OACN6M,KAAMwB,EACN7M,cAAenB,KAInB8M,IAAeA,GAAYmS,QAEvBtS,IAAaD,GACXC,GAAY,IAEdoC,EAAe,CACb1O,SAAUnE,KACVyD,KAAM,SACN6M,KAAMwB,EACN7M,cAAenB,IAGjB+O,EAAe,CACb1O,SAAUnE,KACVyD,KAAM,OACN6M,KAAMwB,EACN7M,cAAenB,KAOnB3F,GAASH,SAEK,MAAZyS,IAAkC,IAAdA,IACtBA,EAAWD,EACXG,GAAoBD,IAGtBmC,EAAe,CACb1O,SAAUnE,KACVyD,KAAM,MACN6M,KAAMwB,EACN7M,cAAenB,IAIjB9D,KAAK+iB,WAxJT/iB,KAAK0f,YA+JTA,SAAU,WACRtQ,EAAY,UAAWpP,MAEvBmQ,EAAS0B,EAASC,EAAWC,EAAUC,EAAS3B,EAAU4B,EAAaC,EAAcc,GAASC,GAAWb,GAAQ3B,EAAWE,GAAoBH,EAAWE,GAAoB4C,GAAaC,GAAgB3C,GAAcmC,GAAc5U,GAASyN,QAAUzN,GAASwN,MAAQxN,GAASkO,MAAQlO,GAASH,OAAS,KAE/SiW,GAAkBrY,SAAQ,SAAU8K,GAClCA,EAAGoX,cAGL7J,GAAkB1X,OAAS2W,GAASC,GAAS,GAG/C6P,YAAa,SAAqBlf,GAChC,OAAQA,EAAIiB,MACV,IAAK,OACL,IAAK,UACH/E,KAAKwe,QAAQ1a,GACb,MAEF,IAAK,YACL,IAAK,WACC+N,IACF7R,KAAKkX,YAAYpT,GAiL3B,SAAoCA,GAC9BA,EAAI2U,eACN3U,EAAI2U,aAAawK,WAAa,QAEhCnf,EAAIuN,YAAcvN,EAAIuS,iBAJxB,CAhL0BvS,IAElB,MAEF,IAAK,cACHA,EAAIuS,mBASVjS,QAAS,WAQP,IAPA,IACEsC,EADExM,EAAQ,GAEVwD,EAAWsC,KAAK0G,GAAGhJ,SACnB7B,EAAI,EACJyN,EAAI5L,EAASnB,OACb6G,EAAUpD,KAAKoD,QAEVvH,EAAIyN,EAAGzN,IAER6L,EADJhB,EAAKhJ,EAAS7B,GACEuH,EAAQyI,UAAW7L,KAAK0G,QACtCxM,EAAMiC,KAAKuK,EAAGwc,aAAa9f,EAAQyV,aAAe6D,GAAYhW,IAIlE,OAAOxM,GAOTsd,KAAM,SAAUtd,GACd,IAAIgK,EAAQ,GACViM,EAASnQ,KAAK0G,GAEhB1G,KAAKoE,UAAUxI,SAAQ,SAAUshB,EAAIrhB,GACnC,IAAI6K,EAAKyJ,EAAOzS,SAAS7B,GAErB6L,EAAQhB,EAAI1G,KAAKoD,QAAQyI,UAAWsE,QACtCjM,EAAMgZ,GAAMxW,KAEb1G,MAEH9F,EAAM0B,SAAQ,SAAUshB,GAClBhZ,EAAMgZ,KACR/M,EAAOrL,YAAYZ,EAAMgZ,IACzB/M,EAAOiQ,YAAYlc,EAAMgZ,SAQ/B6F,KAAM,WACJ,IAAI7gB,EAAQlC,KAAKoD,QAAQlB,MACzBA,GAASA,EAAM1C,KAAO0C,EAAM1C,IAAIQ,OASlC0H,QAAS,SAAUhB,EAAIO,GACrB,OAAOS,EAAQhB,EAAIO,GAAYjH,KAAKoD,QAAQyI,UAAW7L,KAAK0G,QAS9DyI,OAAQ,SAAU1L,EAAM/E,GACtB,IAAI0E,EAAUpD,KAAKoD,QAEnB,YAAI1E,EACF,OAAO0E,EAAQK,GAEf,IAAIuM,EAAgB0B,EAAc7B,aAAa7P,KAAMyD,EAAM/E,GAEzD0E,EAAQK,YADCuM,EACOA,EAEAtR,EAGL,UAAT+E,GACFmS,GAAcxS,IAQpBiC,QAAS,WACP+J,EAAY,UAAWpP,MACvB,IAAI0G,EAAK1G,KAAK0G,GAEdA,EAAGgI,GAAW,KAEd5H,EAAIJ,EAAI,YAAa1G,KAAK0Z,aAC1B5S,EAAIJ,EAAI,aAAc1G,KAAK0Z,aAC3B5S,EAAIJ,EAAI,cAAe1G,KAAK0Z,aAExB1Z,KAAKyZ,kBACP3S,EAAIJ,EAAI,WAAY1G,MACpB8G,EAAIJ,EAAI,YAAa1G,OAGvB0C,MAAMxD,UAAUtD,QAAQwD,KAAKsH,EAAGyc,iBAAiB,gBAAgB,SAC/Dzc,GAEAA,EAAG0c,gBAAgB,gBAGrBpjB,KAAKwe,UAELxe,KAAKye,4BAEL7K,GAAUyG,OAAOzG,GAAUvT,QAAQL,KAAK0G,IAAK,GAE7C1G,KAAK0G,GAAKA,EAAK,MAGjB2Z,WAAY,WACV,IAAKnO,EAAa,CAGhB,GAFA9C,EAAY,YAAapP,MAErB7B,GAASmR,cAAe,OAE5BnH,EAAIkI,EAAS,UAAW,QACpBrQ,KAAKoD,QAAQ2U,mBAAqB1H,EAAQ7L,YAC5C6L,EAAQ7L,WAAWM,YAAYuL,GAEjC6B,OAIJyQ,WAAY,SAAU/R,GACpB,GAAgC,UAA5BA,EAAYY,aAKhB,GAAIU,EAAa,CAGf,GAFA9C,EAAY,YAAapP,MAErB7B,GAASmR,cAAe,OAGxBuC,EAAOrN,YAAc2L,GAAWnQ,KAAKoD,QAAQwB,MAAMwR,YAE5CpE,EACT7B,EAAOzL,aAAa2L,EAAS2B,GAE7B7B,EAAOiQ,YAAY/P,GAJnBF,EAAOzL,aAAa2L,EAASwB,GAO3B7R,KAAKoD,QAAQwB,MAAMwR,aACrBpW,KAAKmb,QAAQtJ,EAAQxB,GAGvBlI,EAAIkI,EAAS,UAAW,IACxB6B,WAvBAlS,KAAKqgB,eAiOPnM,IACFzN,EAAGe,SAAU,aAAa,SAAU1D,IAE7B3F,GAASH,QAAU0V,KAAwB5P,EAAIuN,YAClDvN,EAAIuS,oBAMVlY,GAASklB,MAAQ,CACf5c,GAAIA,EACJK,IAAKA,EACLqB,IAAKA,EACLe,KAAMA,EACNoa,GAAI,SAAU5c,EAAIO,GAChB,QAASS,EAAQhB,EAAIO,EAAUP,OAEjC6c,OH1lDF,SAAgBC,EAAK5G,GACnB,GAAI4G,GAAO5G,EACT,IAAK,IAAI3d,KAAO2d,EACVA,EAAIzd,eAAeF,KACrBukB,EAAIvkB,GAAO2d,EAAI3d,IAKrB,OAAOukB,GGklDP7V,SAAUA,EACVjG,QAASA,EACTK,YAAaA,EACbsE,MAAOA,EACPH,MAAOA,EACPuX,SAAUzG,GACV0G,eAAgBzG,GAChB0G,gBAAiBlP,GACjBlJ,SAAUA,GAQZpN,GAASoB,IAAM,SAAUqkB,GACvB,OAAOA,EAAQlV,IAOjBvQ,GAAS8Q,MAAQ,eAAaJ,2BACxBA,EAAQ,GAAGjO,cAAgB8B,QAAOmM,EAAUA,EAAQ,IAExDA,EAAQjT,SAAQ,SAACsT,GACf,IAAKA,EAAOhQ,YAAcgQ,EAAOhQ,UAAU0B,YACzC,KAAM,gEAAgE,GAAGyW,SAASjY,KAChF8P,GAGAA,EAAOmU,QAAOllB,GAASklB,WAAallB,GAASklB,MAAUnU,EAAOmU,QAElE3R,EAAczC,MAAMC,OASxB/Q,GAAS8E,OAAS,SAAUyD,EAAItD,GAC9B,WAAWjF,GAASuI,EAAItD,IAI1BjF,GAAS0lB,iBG7kET,IAEEC,GACAC,GAIAlS,GACAmS,GACAC,GATEC,GAAoB,GACtBC,GAAkB,GAGlBC,MACAC,MACAlS,MAipBF,SAASmS,GAAsBC,EAAkBpU,GAC/CgU,GAAgBvoB,SAAQ,SAACyQ,EAAOxQ,GAC9B,IAAI+D,EACFuQ,EAAOzS,SAAS2O,EAAMmY,eAAiBD,EAAmBtL,OAAOpd,GAAK,IACpE+D,EACFuQ,EAAOzL,aAAa2H,EAAOzM,GAE3BuQ,EAAOiQ,YAAY/T,MAKzB,SAASoY,KACPP,GAAkBtoB,SAAQ,SAAC8oB,GACrBA,IAAqB7S,IACzB6S,EAAiBlgB,YACfkgB,EAAiBlgB,WAAWM,YAAY4f,MCtrB9C,IAAMC,GAAO,gBACX1f,kBACA2L,gBACAiB,WAEAe,0BAEAJ,yBAEA,GAAKvN,EAAL,CACA,IAAI2f,EAAahU,KANjByB,kBAOAC,EALAA,sBAMA,IAAI+K,EACFpY,EAAc4f,gBAAkB5f,EAAc4f,eAAetoB,OACzD0I,EAAc4f,eAAe,GAC7B5f,EACFrF,EAAS4H,SAASoY,iBAAiBvC,EAAMzG,QAASyG,EAAMxG,SAC5DrE,IACIoS,IAAeA,EAAWle,GAAGyW,SAASvd,KACxCgT,EAAsB,SACtB5S,KAAK8kB,QAAQ,CAAEjT,SAAQjB,mBAI3B,SAASmU,MA+BT,SAASC,MA7BTD,GAAO7lB,UAAY,CACjB+lB,WAAY,KACZC,sBACEllB,KAAKilB,aADKvU,mBAGZoU,wBAAUjT,WAAQjB,gBAChB5Q,KAAKmE,SAASwV,wBACV/I,GACFA,EAAY+I,wBAEd,IAAIxX,EAAcoJ,EAASvL,KAAKmE,SAASuC,GAAI1G,KAAKilB,WAAYjlB,KAAKoD,SAE/DjB,EACFnC,KAAKmE,SAASuC,GAAGhC,aAAamN,EAAQ1P,GAEtCnC,KAAKmE,SAASuC,GAAG0Z,YAAYvO,GAE/B7R,KAAKmE,SAASoW,aACV3J,GACFA,EAAY2J,cAGhBoK,SAGFnmB,OAAOmB,OAAOolB,GAAQ,CACpBtV,WAAY,kBAKduV,GAAO9lB,UAAY,CACjB4lB,wBAAUjT,WACFsT,IADUvU,aACsB5Q,KAAKmE,SAC3CghB,EAAexL,wBACf9H,EAAOrN,YAAcqN,EAAOrN,WAAWM,YAAY+M,GACnDsT,EAAe5K,cAEjBoK,SAGFnmB,OAAOmB,OAAOqlB,GAAQ,CACpBvV,WAAY,kBCpDd,IACE2V,GACAC,GAEAC,GACAC,GACAtS,GACAuS,GAPEC,GAAc,GAGhBC,MAuIF,SAASC,KACPF,GAAY7pB,SAAQ,SAAUgqB,GAC5B9C,cAAc8C,EAAWC,QAE3BJ,GAAc,GAGhB,SAASK,KACPhD,cAAc0C,IAGhB,IAAMI,GAAajY,GAAS,SAAU7J,EAAKV,EAAS+M,EAAQ4V,GAE1D,GAAK3iB,EAAQ4iB,OAAb,CACA,IAOEC,EAPIlY,GAAKjK,EAAI6S,QAAU7S,EAAI6S,QAAQ,GAAK7S,GAAK8S,QAC7C5I,GAAKlK,EAAI6S,QAAU7S,EAAI6S,QAAQ,GAAK7S,GAAK+S,QACzCqP,EAAO9iB,EAAQ+iB,kBACfC,EAAQhjB,EAAQijB,YAChB5Z,EAAclD,IAEZ+c,KAIAjB,KAAiBlV,IACnBkV,GAAelV,EAEfwV,KAGAM,EAAiB7iB,EAAQmjB,eADzBnB,GAAWhiB,EAAQ4iB,UAIjBZ,GAAWha,EAA2B+E,QAI1C,IAAIqW,EAAY,EACZC,EAAgBrB,GACpB,EAAG,CACD,IAAI1e,EAAK+f,EAEPjY,EAAO9E,EAAQhD,GACfuD,EAAMuE,EAAKvE,IACXE,EAASqE,EAAKrE,OACdD,EAAOsE,EAAKtE,KACZE,EAAQoE,EAAKpE,MACbE,EAAQkE,EAAKlE,MACbD,EAASmE,EAAKnE,OACdqc,SACAC,SACA3Z,EAActG,EAAGsG,YACjBE,EAAexG,EAAGwG,aAElBwH,EAAQvM,EAAIzB,GACZkgB,EAAalgB,EAAGgG,WAChBma,EAAangB,EAAGiG,UAEdjG,IAAO+F,GACTia,EACEpc,EAAQ0C,IACa,SAApB0H,EAAMtH,WACe,WAApBsH,EAAMtH,WACc,YAApBsH,EAAMtH,WACVuZ,EACEtc,EAAS6C,IACY,SAApBwH,EAAMrH,WACe,WAApBqH,EAAMrH,WACc,YAApBqH,EAAMrH,aAEVqZ,EACEpc,EAAQ0C,IACa,SAApB0H,EAAMtH,WAA4C,WAApBsH,EAAMtH,WACvCuZ,EACEtc,EAAS6C,IACY,SAApBwH,EAAMrH,WAA4C,WAApBqH,EAAMrH,YAGzC,IAAIyZ,EACFJ,IAECjZ,KAAKqR,IAAI1U,EAAQ2D,IAAMmY,GAAQU,EAAatc,EAAQ0C,IAElDS,KAAKqR,IAAI5U,EAAO6D,IAAMmY,KAAUU,GACjCG,EACFJ,IAEClZ,KAAKqR,IAAI3U,EAAS6D,IAAMkY,GAAQW,EAAaxc,EAAS6C,IAEpDO,KAAKqR,IAAI7U,EAAM+D,IAAMkY,KAAUW,GAEpC,IAAKpB,GAAYe,GACf,IAAK,IAAI3qB,EAAI,EAAGA,GAAK2qB,EAAW3qB,IACzB4pB,GAAY5pB,KACf4pB,GAAY5pB,GAAK,IAMrB4pB,GAAYe,GAAWM,IAAMA,GAC7BrB,GAAYe,GAAWO,IAAMA,GAC7BtB,GAAYe,GAAW9f,KAAOA,IAE9B+e,GAAYe,GAAW9f,GAAKA,EAC5B+e,GAAYe,GAAWM,GAAKA,EAC5BrB,GAAYe,GAAWO,GAAKA,EAE5BjE,cAAc2C,GAAYe,GAAWX,KAE3B,GAANiB,GAAiB,GAANC,IACbT,KAEAb,GAAYe,GAAWX,IAAMrF,YAC3B,WAEMuF,GAA6B,IAAf/lB,KAAKgnB,OAErB7oB,GAASH,OAAOghB,aAAa/L,IAE/B,IAAIgU,EAAgBxB,GAAYzlB,KAAKgnB,OAAOD,GACxCtB,GAAYzlB,KAAKgnB,OAAOD,GAAKX,EAC7B,EACAc,EAAgBzB,GAAYzlB,KAAKgnB,OAAOF,GACxCrB,GAAYzlB,KAAKgnB,OAAOF,GAAKV,EAC7B,EAE0B,mBAAnBH,GAUD,aARNA,EAAe7mB,KAEbjB,GAASyN,QAAQpH,WAAWkK,GAC5BwY,EACAD,EACAnjB,EACAmP,GACAwS,GAAYzlB,KAAKgnB,OAAOtgB,KAO9BoH,EAAS2X,GAAYzlB,KAAKgnB,OAAOtgB,GAAIwgB,EAAeD,IACpDrV,KAAK,CAAEoV,MAAOR,IAChB,MAINA,UACOpjB,EAAQ+jB,cAAgBV,IAAkBha,IAAgBga,EAAgBrb,EAA2Bqb,QAC9Gf,GAAYY,KACX,IC7SHnoB,GAAS8Q,MAAM,IDoBf,WACE,SAASmY,IASP,IAAK,IAAIxgB,KART5G,KAAK8O,SAAW,CACdkX,UACAG,kBAAmB,GACnBE,YAAa,GACbc,iBAAc,KAKO,MAAjBvgB,EAAGmK,OAAO,IAAkC,wBAARnK,KACtC5G,KAAK4G,GAAM5G,KAAK4G,GAAIgL,KAAK5R,OA+G/B,OA1GAonB,EAAWloB,UAAY,CACrBiT,4BAAclN,kBACRjF,KAAKmE,SAASsV,gBAChBhT,EAAGe,SAAU,WAAYxH,KAAKqnB,mBAG5B5gB,EAAGe,SADDxH,KAAKoD,QAAQoW,eACF,cACJvU,EAAc0R,QACV,YAEA,YAJe3W,KAAKsnB,4BASvCC,kCAAoBtiB,kBAEbjF,KAAKoD,QAAQokB,gBAAmBviB,EAAckL,QACjDnQ,KAAKqnB,kBAAkBpiB,IAI3B0f,gBACM3kB,KAAKmE,SAASsV,gBAChB3S,EAAIU,SAAU,WAAYxH,KAAKqnB,oBAE/BvgB,EAAIU,SAAU,cAAexH,KAAKsnB,2BAClCxgB,EAAIU,SAAU,YAAaxH,KAAKsnB,2BAChCxgB,EAAIU,SAAU,YAAaxH,KAAKsnB,4BAGlCxB,KACAH,KRgbJnL,aAAa3S,GACbA,UQ7aE4f,mBACExU,GAAWoS,GAAeD,GAAWM,GAAYF,GAA6BF,GAAkBC,GAAkB,KAElHE,GAAYlpB,OAAS,GAGvB+qB,mCAA0BxjB,GACxB9D,KAAKqnB,kBAAkBvjB,OAGzBujB,2BAAkBvjB,EAAK0b,cACfzR,GAAKjK,EAAI6S,QAAU7S,EAAI6S,QAAQ,GAAK7S,GAAK8S,QAC7C5I,GAAKlK,EAAI6S,QAAU7S,EAAI6S,QAAQ,GAAK7S,GAAK+S,QACzChK,EAAOrF,SAASoY,iBAAiB7R,EAAGC,GAQtC,GANAiF,GAAWnP,EAMP0b,GAAYvZ,GAAQD,GAAcG,EAAQ,CAE5Cyf,GAAW9hB,EAAK9D,KAAKoD,QAASyJ,EAAM2S,GAGpC,IAAIkI,EAAiBtc,EAA2ByB,OAE9C6Y,IACEF,IACAzX,IAAMuX,IACNtX,IAAMuX,KAERC,IAA8BM,KAE9BN,GAA6BhF,aAAY,WACvC,IAAImH,EAAUvc,EACZ5D,SAASoY,iBAAiB7R,EAAGC,OAG3B2Z,IAAYD,IACdA,EAAiBC,EACjBhC,MAGFC,GAAW9hB,EAAKvB,EAAKa,QAASukB,EAASnI,KACtC,IACH8F,GAAkBvX,EAClBwX,GAAkBvX,OAEf,CAEL,IACGhO,KAAKoD,QAAQ+jB,cACd/b,EAA2ByB,QAAgBtD,IAG3C,YADAoc,KAGFC,GAEE9hB,EACA9D,KAAKoD,QACLgI,EAA2ByB,OAAM,MAOlCrO,OAAOmB,OAAOynB,EAAY,CAC/B3X,WAAY,SACZV,2BChJJ5Q,GAAS8Q,MAAM2Y,GAAeC,IAE9B1pB,GAAS8Q,MAAM,ILNf,WACE,SAAS6Y,IACP9nB,KAAK8O,SAAW,CACdiZ,UAAW,2BA6Df,OAzDAD,EAAK5oB,UAAY,CACfgmB,sBACE1O,KADU3E,QAGZmW,8BACE7G,cACAvhB,WAGAyhB,YACA9R,WAEA,KAJA8C,eAIoBjP,QAAQ6kB,KAA5B,CACA,IACE7kB,EAAUpD,KAAKoD,QACjB,GAAIxD,GAAUA,IAFLI,KAAKmE,SAASuC,GAEM,CAC3B,IAAIwhB,EAAa1R,SACM,EAAnBuF,EAVNA,QAUanc,IACTmI,EAAYnI,EAAQwD,EAAQ2kB,cAC5BvR,GAAa5W,GAEb4W,GAAa,KAGX0R,GAAcA,IAAe1R,IAC/BzO,EAAYmgB,EAAY9kB,EAAQ2kB,cAGpC1G,IAEAF,MACA5R,MAEFoV,qBAkCewD,EAAIC,EAGnBC,EACAC,EAHEC,EACFC,EApCOnW,mBAAgBzB,gBAAaiB,WAC9B+S,EAAahU,GAAe5Q,KAAKmE,SACjCf,EAAUpD,KAAKoD,QACnBoT,IAAczO,EAAYyO,GAAYpT,EAAQ2kB,cAE5CvR,KACCpT,EAAQ6kB,MAASrX,GAAeA,EAAYxN,QAAQ6kB,OAEjDpW,IAAW2E,KACboO,EAAWjL,wBACPiL,IAAevS,GACjBA,EAAesH,wBAyBvB6O,GAFmBJ,EAtBK5R,IAwBhBhS,YADN+jB,GADaJ,EAtBCtW,GAuBNrN,aAKAgkB,IAAMD,EAAGE,YAAYL,KAAOI,EAAGC,YAAYN,KAGvDE,EAAKnc,EAAMic,GAEXG,EAAKpc,EAAMkc,GAEPG,EAAGE,YAAYD,IAAOH,EAAKC,GAC7BA,IAEFC,EAAG7jB,aAAa0jB,EAAIG,EAAG7qB,SAAS2qB,IAChCG,EAAG9jB,aAAayjB,EAAIK,EAAG9qB,SAAS4qB,KArCxB1D,EAAWrK,aACPqK,IAAevS,GAAgBA,EAAekI,eAIxDkN,mBACEjR,GAAa,OAIVhY,OAAOmB,OAAOmoB,EAAM,CACzBrY,WAAY,OACZM,2BACE,MAAO,CACL2Y,SAAUlS,SK5DlBrY,GAAS8Q,MAAM,IHgBf,WACE,SAAS0Z,EAAUxkB,GAEjB,IAAK,IAAIyC,UACc,MAAjBA,EAAGmK,OAAO,IAAkC,wBAARnK,KACtC5G,KAAK4G,GAAM5G,KAAK4G,GAAIgL,KAAK5R,OAIzBmE,EAASf,QAAQoW,eACnB/S,EAAGe,SAAU,YAAaxH,KAAK4oB,qBAE/BniB,EAAGe,SAAU,UAAWxH,KAAK4oB,oBAC7BniB,EAAGe,SAAU,WAAYxH,KAAK4oB,qBAGhCniB,EAAGe,SAAU,UAAWxH,KAAK6oB,eAC7BpiB,EAAGe,SAAU,QAASxH,KAAK8oB,aAE3B9oB,KAAK8O,SAAW,CACdia,cAAe,oBACfC,aAAc,KACdxQ,iBAAQC,EAAc5G,GACpB,IAAIF,EAAO,GACPuS,GAAkB3nB,QAAUwnB,KAAsB5f,EACpD+f,GAAkBtoB,SAAQ,SAAC8oB,EAAkB7oB,GAC3C8V,IAAU9V,EAAS,KAAL,IAAa6oB,EAAiBhM,eAG9C/G,EAAOE,EAAO6G,YAEhBD,EAAaD,QAAQ,OAAQ7G,KAsgBnC,OAjgBAgX,EAAUzpB,UAAY,CACpB+pB,oBACAC,eAEAC,6BACEtX,KADiBA,QAInBuX,sBACEppB,KAAKkpB,aAAehF,GAAkB7jB,QAAQwR,KAGhDwX,2BAAallB,aAAUoL,WACrB,GAAKvP,KAAKkpB,YAAV,CACA,IAAK,IAAIrtB,EAAI,EAAGA,EAAIqoB,GAAkB3nB,OAAQV,IAC5CsoB,GAAgBhoB,KAAKkQ,EAAM6X,GAAkBroB,KAE7CsoB,GAAgBtoB,GAAG2oB,cAAgBN,GAAkBroB,GAAG2oB,cAExDL,GAAgBtoB,GAAGgQ,aACnBsY,GAAgBtoB,GAAG4J,MAAM,eAAiB,GAE1CsC,EAAYoc,GAAgBtoB,GAAImE,KAAKoD,QAAQ2lB,kBAC7C7E,GAAkBroB,KAAOgW,IACvB9J,EAAYoc,GAAgBtoB,GAAImE,KAAKoD,QAAQ8U,gBAGjD/T,EAASkc,aACT9Q,MAGFlD,sBAA0BuG,0BAAuBrD,WAC1CvP,KAAKkpB,cACLlpB,KAAKoD,QAAQ2U,mBACZmM,GAAkB3nB,QAAUwnB,OAH5B5f,WAIFmgB,MAAsBgF,EAJVnZ,QAKZyC,EAAsB,SAEtBrD,OAKNga,0BAAY5W,kBAAuBpD,WAC5BvP,KAAKkpB,cACV5E,MAAsB,EAFGnU,QAGzBgU,GAAgBvoB,SAAQ,SAACyQ,GACvBlE,EAAIkE,EAAO,UAAW,OAGxBsG,IACAsR,MACA1U,MAGFia,iCAAsB9W,mBAAgBnD,WAC/BvP,KAAKkpB,cACV/E,GAAgBvoB,SAAQ,SAACyQ,GACvBlE,EAAIkE,EAAO,UAAW,QAClB9J,EAAKa,QAAQ2U,mBAAqB1L,EAAM7H,YAC1C6H,EAAM7H,WAAWM,YAAYuH,MAIjCqG,IACAuR,MACA1U,MAGFka,6BACOzpB,KAAKkpB,aAAenF,IACvBA,GAAkB2F,UAAUd,qBAG9B1E,GAAkBtoB,SAAQ,SAAC8oB,GAEzBA,EAAiBF,cAAgBtY,EAAMwY,MAIzCR,GAAoBA,GAAkB1M,MAAK,SAAU3M,EAAGoV,GACtD,OAAOpV,EAAE2Z,cAAgBvE,EAAEuE,iBAE7BrS,OAGFA,mCAAchO,aACZ,GAAKnE,KAAKkpB,YAAV,CACA,GAAIlpB,KAAKoD,QAAQoU,OAQfrT,EAASwV,wBAEL3Z,KAAKoD,QAAQkV,WAAW,CAC1B4L,GAAkBtoB,SAAQ,SAAC8oB,GACrBA,IAAqB7S,IACzB1J,EAAIuc,EAAkB,WAAY,eAIpC,IAAI1I,EAAWtS,EAAQmI,OAAQ,GAAO,GAEtCqS,GAAkBtoB,SAAQ,SAAC8oB,GACrBA,IAAqB7S,IACzBtD,EAAQmW,EAAkB1I,MAG5BqI,MACAD,MAIJjgB,EAASoW,YAAW,WAClB8J,MACAD,MAEIjhB,EAAKC,QAAQkV,WACf4L,GAAkBtoB,SAAQ,SAAC8oB,GACzBjW,EAAUiW,MAKVvhB,EAAKC,QAAQoU,MACfiN,UAKNkF,yBAAmBxI,cAAW5R,WACxB8U,KAAYH,GAAkB7jB,UADzBT,UAEPuhB,MACA5R,MAIJoR,uBAASI,iBAAc5Q,WAAQhM,aAAU6X,aACnCkI,GAAkB3nB,OAAS,IAE7B2nB,GAAkBtoB,SAAQ,SAAC8oB,GACzBvgB,EAASgW,kBAAkB,CACzBva,OAAQ8kB,EAERlW,KAAM6V,GAAU3a,EAAQgb,GAAoB1I,IAG9CvN,EAAUiW,GAEVA,EAAiB5K,SAAWkC,EAE5B+E,EAAa3G,qBAAqBsK,MAEpCL,MAwbR,SAAiCuF,EAAgBzZ,GAC/C+T,GAAkBtoB,SAAQ,SAAC8oB,EAAkB7oB,GAC3C,IAAI+D,EACFuQ,EAAOzS,SACLgnB,EAAiBF,eAAiBoF,EAAiB3Q,OAAOpd,GAAK,IAE/D+D,EACFuQ,EAAOzL,aAAaggB,EAAkB9kB,GAEtCuQ,EAAOiQ,YAAYsE,MATzB,EAvbiC1kB,KAAKoD,QAAQ2U,kBAAmB5H,KAI7DoX,kCACEpjB,aACA0c,YAEAxO,mBACAP,aACAlB,gBAEIxN,EAAUpD,KAAKoD,QACnB,KANAsf,UAMe,CAQb,GANI7B,GACFxO,EAAegO,aAGjB+D,MAGEhhB,EAAQkV,WACR4L,GAAkB3nB,OAAS,IAC1B8nB,KACGxD,IAAYxO,EAAejP,QAAQoU,OAAS5G,GAChD,CAGA,IAAIiZ,EAAmBngB,EAAQmI,OAAQ,GAAO,GAE9CqS,GAAkBtoB,SAAQ,SAAC8oB,GACrBA,IAAqB7S,KACzBtD,EAAQmW,EAAkBmF,GAI1B/X,EAASsO,YAAYsE,OAGvBL,MAIF,IAAKxD,EAMH,GAJKwD,IACHI,KAGEP,GAAkB3nB,OAAS,EAAG,CAChC,IAAIutB,EAAqB7F,GACzB5R,EAAesQ,WAAWxe,GAIxBkO,EAAejP,QAAQkV,YACtB2L,IACD6F,GAEA3F,GAAgBvoB,SAAQ,SAACyQ,GACvBgG,EAAe8H,kBAAkB,CAC/Bva,OAAQyM,EACRmC,KAAMwV,KAGR3X,EAAMyN,SAAWkK,GACjB3X,EAAM0N,sBAAwB,aAIlC1H,EAAesQ,WAAWxe,KAMlC4lB,yCAA2B/N,aAAU6E,YAASxO,mBAK5C,GAJA6R,GAAkBtoB,SAAQ,SAAC8oB,GACzBA,EAAiB3K,sBAAwB,QAIzC1H,EAAejP,QAAQkV,YACtBuI,GACDxO,EAAeqX,UAAUR,YACzB,CACAlF,GAAiBxlB,OAAOmB,OAAO,GAAIqc,GACnC,IAAIgO,EAAavhB,EAAOoJ,OACxBmS,GAAe/Z,KAAO+f,EAAW/P,EACjC+J,GAAe9Z,MAAQ8f,EAAW9P,IAItC+P,qCACM5F,KACFA,MACAI,OAIJE,qBACiB7gB,IAAfmB,cACAkL,WACA2B,aACA3N,aACAyO,0BACApC,aACAI,gBAEIgU,EAAahU,GAAe5Q,KAAKmE,SAErC,GAAKL,EAAL,CAEA,IAAIV,EAAUpD,KAAKoD,QACjB1F,EAAWoU,EAASpU,SAGtB,IAAKyU,GAUH,GATI/O,EAAQ4lB,eAAiBhpB,KAAKipB,kBAChCjpB,KAAK4oB,qBAEP7gB,EACE8J,GACAzO,EAAQ2lB,gBACN7E,GAAkB7jB,QAAQwR,MAGxBqS,GAAkB7jB,QAAQwR,IAuD9BqS,GAAkB7J,OAAO6J,GAAkB7jB,QAAQwR,IAAS,GAC5DiS,GAAsB,KACtB5T,EAAc,CACZ/L,WACAgM,SACA1M,KAAM,WACN2M,SAAUyB,GAEVqY,YAAapmB,QA/DwB,CAYvC,GAXAogB,GAAkB/nB,KAAK0V,IACvB3B,EAAc,CACZ/L,WACAgM,SACA1M,KAAM,SACN2M,SAAUyB,GAEVqY,YAAapmB,IAKbA,EAAIqmB,UACJrG,IACA3f,EAASuC,GAAGyW,SAAS2G,IACrB,CAEA,IAOMxa,EAAGzN,EAPLuuB,EAAYle,EAAM4X,IAEpBuG,EAAene,EAAM2F,IAEvB,IAAKuY,IAAcC,GAAgBD,IAAcC,EAY/C,IARIA,EAAeD,GACjBvuB,EAAIuuB,EACJ9gB,EAAI+gB,IAEJxuB,EAAIwuB,EACJ/gB,EAAI8gB,EAAY,GAGXvuB,EAAIyN,EAAGzN,KACPqoB,GAAkB7jB,QAAQ3C,EAAS7B,MACxCkM,EAAYrK,EAAS7B,GAAIuH,EAAQ2lB,kBACjC7E,GAAkB/nB,KAAKuB,EAAS7B,IAEhCqU,EAAc,CACZ/L,WACAgM,SACA1M,KAAM,SACN2M,SAAU1S,EAAS7B,GAEnBquB,YAAapmB,UAKnBggB,GAAsBjS,GAGxBkS,GAAoBa,EAgBxB,GAAIzS,IAAenS,KAAKkpB,YAAa,CAEnC,IACGpX,EAASpD,GAAStL,QAAQoU,MAAQ1F,IAAa3B,IAChD+T,GAAkB3nB,OAAS,EAC3B,CAEA,IAAIyf,EAAWtS,EAAQmI,IACrByY,EAAiBpe,EACf2F,GACA,SAAW7R,KAAKoD,QAAQ2lB,cAAgB,KAQ5C,IALK3E,IAAkBhhB,EAAQkV,YAC7BzG,GAAOkI,sBAAwB,MAEjC6K,EAAWjL,yBAENyK,KACChhB,EAAQkV,YACVzG,GAAOiI,SAAWkC,EAClBkI,GAAkBtoB,SAAQ,SAAC8oB,GAEzB,GADAA,EAAiB3K,sBAAwB,KACrC2K,IAAqB7S,GAAQ,CAE/B,IAAIrD,EAAO6V,GAAU3a,EAAQgb,GAAoB1I,EACjD0I,EAAiB5K,SAAWtL,EAG5BoW,EAAWzK,kBAAkB,CAC3Bva,OAAQ8kB,EACRlW,KAAMA,SAQdiW,KAEAP,GAAkBtoB,SAAQ,SAAC8oB,GACrBhnB,EAAS4sB,GACXxY,EAASpN,aACPggB,EACAhnB,EAAS4sB,IAGXxY,EAASsO,YAAYsE,GAEvB4F,OAOE9Z,IAAatE,EAAM2F,KAAS,CAC9B,IAAI0Y,KACJrG,GAAkBtoB,SAAQ,SAAC8oB,GAIvBA,EAAiBF,gBAAkBtY,EAAMwY,KAEzC6F,SAKAA,GACF3X,EAAsB,UAM5BsR,GAAkBtoB,SAAQ,SAAC8oB,GACzBjW,EAAUiW,MAGZE,EAAWrK,aAGbwJ,GAAoBa,GAKpBzU,IAAW2B,GACVlB,GAA2C,UAA5BA,EAAYY,cAE5B2S,GAAgBvoB,SAAQ,SAACyQ,GACvBA,EAAM7H,YAAc6H,EAAM7H,WAAWM,YAAYuH,QAKvDme,yBACExqB,KAAKkpB,YAAc/W,MACnBgS,GAAgB5nB,OAAS,GAG3BkuB,yBACEzqB,KAAK4oB,qBACL9hB,EAAIU,SAAU,YAAaxH,KAAK4oB,oBAChC9hB,EAAIU,SAAU,UAAWxH,KAAK4oB,oBAC9B9hB,EAAIU,SAAU,WAAYxH,KAAK4oB,oBAE/B9hB,EAAIU,SAAU,UAAWxH,KAAK6oB,eAC9B/hB,EAAIU,SAAU,QAASxH,KAAK8oB,cAG9BF,4BAAmB9kB,GACjB,cAAWqO,IAA+BA,IAGtC4R,KAAsB/jB,KAAKmE,UAI7BL,GACA4D,EAAQ5D,EAAIlE,OAAQI,KAAKoD,QAAQyI,UAAW7L,KAAKmE,SAASuC,QAKxD5C,GAAsB,IAAfA,EAAIia,QAEf,KAAOmG,GAAkB3nB,QAAQ,CAC/B,IAAImK,EAAKwd,GAAkB,GAC3Bnc,EAAYrB,EAAI1G,KAAKoD,QAAQ2lB,kBAC7B7E,GAAkBwG,QAClBxa,EAAc,CACZ/L,SAAUnE,KAAKmE,SACfgM,OAAQnQ,KAAKmE,SAASuC,GACtBjD,KAAM,WAEN2M,SAAU1J,EAEVwjB,YAAapmB,MAKnB+kB,uBAAc/kB,GACRA,EAAI7E,MAAQe,KAAKoD,QAAQ4lB,eAC3BhpB,KAAKipB,sBAITH,qBAAYhlB,GACNA,EAAI7E,MAAQe,KAAKoD,QAAQ4lB,eAC3BhpB,KAAKipB,uBAKJzqB,OAAOmB,OAAOgpB,EAAW,CAE9BlZ,WAAY,YACZ4T,MAAO,CAKLsH,gBAAOjkB,GACL,IAAIvC,EAAWuC,EAAGlC,WAAWkK,GAE1BvK,GACAA,EAASf,QAAQsmB,aACjBxF,GAAkB7jB,QAAQqG,KAGzBqd,IAAqBA,KAAsB5f,IAC7C4f,GAAkB2F,UAAUd,qBAC5B7E,GAAoB5f,GAEtB4D,EAAYrB,EAAIvC,EAASf,QAAQ2lB,kBACjC7E,GAAkB/nB,KAAKuK,KAMzBkkB,kBAASlkB,GACP,IAAIvC,EAAWuC,EAAGlC,WAAWkK,GAC3BxC,EAAQgY,GAAkB7jB,QAAQqG,GAC/BvC,GAAaA,EAASf,QAAQsmB,YAAexd,IAClDnE,EAAYrB,EAAIvC,EAASf,QAAQ2lB,kBACjC7E,GAAkB7J,OAAOnO,EAAO,MAGpC6D,sCACQ8a,EAAc,GAClBC,EAAc,GA0BhB,OAxBA5G,GAAkBtoB,SAAQ,SAAC8oB,GAOzB,IAAIjU,EANJoa,EAAY1uB,KAAK,CACfuoB,mBACAxY,MAAOwY,EAAiBF,gBAMxB/T,EADE4T,IAAWK,IAAqB7S,IACtB,EACHwS,GACEnY,EACTwY,EACA,SAAWpf,EAAKlC,QAAQ2lB,cAAgB,KAI/B7c,EAAMwY,GAEnBoG,EAAY3uB,KAAK,CACfuoB,mBACAxY,MAAOuE,OAGJ,CACLvM,gBAAWggB,IACX6G,iBAAY5G,IACZ0G,cACAC,gBAGJ7a,gBAAiB,CACf+Y,sBAAa/pB,GAOX,MALY,UADZA,EAAMA,EAAI+rB,eAER/rB,EAAM,UACGA,EAAI1C,OAAS,IACtB0C,EAAMA,EAAI8R,OAAO,GAAG3E,cAAgBnN,EAAI+R,OAAO,IAE1C/R,sB,iCI/oBf,6EAMI7E,EAAY,CACdC,IAAKC,IACLM,UAAWlB,IAAUG,OACrBgB,UAAWnB,IAAUoB,OACrBsC,SAAU1D,IAAUC,UAAU,CAACD,IAAUoB,OAAQpB,IAAUG,OAAQH,IAAU2D,QAM3E4tB,EAAW,SAAkB1vB,GAC/B,IAAIX,EAAYW,EAAMX,UAClBC,EAAYU,EAAMV,UAClBuC,EAAW7B,EAAM6B,SACjB5B,EAAMD,EAAMlB,IACZoB,EAAaC,YAA8BH,EAAO,CAAC,YAAa,YAAa,WAAY,QAEzFiB,EAAUJ,YAAgBC,IAAWzB,EAAW,aAAcC,GAClE,OAAoB4B,IAAMC,cAAclB,EAAKmB,YAAS,GAAIlB,EAAY,CACpEb,UAAW4B,EACXe,IAAKH,MAIT6tB,EAAS7wB,UAAYA,EACrB6wB,EAAShwB,aAnBU,CACjBZ,IAAK,OAmBQ4wB","file":"static/js/27.bbc23fb9.chunk.js","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { mapToCssModules, tagPropType, isObject } from './utils';\nvar colWidths = ['xs', 'sm', 'md', 'lg', 'xl'];\nvar stringOrNumberProp = PropTypes.oneOfType([PropTypes.number, PropTypes.string]);\nvar columnProps = PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.string, PropTypes.shape({\n  size: PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.string]),\n  order: stringOrNumberProp,\n  offset: stringOrNumberProp\n})]);\nvar propTypes = {\n  tag: tagPropType,\n  xs: columnProps,\n  sm: columnProps,\n  md: columnProps,\n  lg: columnProps,\n  xl: columnProps,\n  className: PropTypes.string,\n  cssModule: PropTypes.object,\n  widths: PropTypes.array\n};\nvar defaultProps = {\n  tag: 'div',\n  widths: colWidths\n};\n\nvar getColumnSizeClass = function getColumnSizeClass(isXs, colWidth, colSize) {\n  if (colSize === true || colSize === '') {\n    return isXs ? 'col' : \"col-\" + colWidth;\n  } else if (colSize === 'auto') {\n    return isXs ? 'col-auto' : \"col-\" + colWidth + \"-auto\";\n  }\n\n  return isXs ? \"col-\" + colSize : \"col-\" + colWidth + \"-\" + colSize;\n};\n\nvar Col = function Col(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      widths = props.widths,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, [\"className\", \"cssModule\", \"widths\", \"tag\"]);\n\n  var colClasses = [];\n  widths.forEach(function (colWidth, i) {\n    var columnProp = props[colWidth];\n    delete attributes[colWidth];\n\n    if (!columnProp && columnProp !== '') {\n      return;\n    }\n\n    var isXs = !i;\n\n    if (isObject(columnProp)) {\n      var _classNames;\n\n      var colSizeInterfix = isXs ? '-' : \"-\" + colWidth + \"-\";\n      var colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);\n      colClasses.push(mapToCssModules(classNames((_classNames = {}, _classNames[colClass] = columnProp.size || columnProp.size === '', _classNames[\"order\" + colSizeInterfix + columnProp.order] = columnProp.order || columnProp.order === 0, _classNames[\"offset\" + colSizeInterfix + columnProp.offset] = columnProp.offset || columnProp.offset === 0, _classNames)), cssModule));\n    } else {\n      var _colClass = getColumnSizeClass(isXs, colWidth, columnProp);\n\n      colClasses.push(_colClass);\n    }\n  });\n\n  if (!colClasses.length) {\n    colClasses.push('col');\n  }\n\n  var classes = mapToCssModules(classNames(className, colClasses), cssModule);\n  return /*#__PURE__*/React.createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n};\n\nCol.propTypes = propTypes;\nCol.defaultProps = defaultProps;\nexport default Col;","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { mapToCssModules, tagPropType } from './utils';\nvar rowColWidths = ['xs', 'sm', 'md', 'lg', 'xl'];\nvar rowColsPropType = PropTypes.oneOfType([PropTypes.number, PropTypes.string]);\nvar propTypes = {\n  tag: tagPropType,\n  noGutters: PropTypes.bool,\n  className: PropTypes.string,\n  cssModule: PropTypes.object,\n  form: PropTypes.bool,\n  xs: rowColsPropType,\n  sm: rowColsPropType,\n  md: rowColsPropType,\n  lg: rowColsPropType,\n  xl: rowColsPropType\n};\nvar defaultProps = {\n  tag: 'div',\n  widths: rowColWidths\n};\n\nvar Row = function Row(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      noGutters = props.noGutters,\n      Tag = props.tag,\n      form = props.form,\n      widths = props.widths,\n      attributes = _objectWithoutPropertiesLoose(props, [\"className\", \"cssModule\", \"noGutters\", \"tag\", \"form\", \"widths\"]);\n\n  var colClasses = [];\n  widths.forEach(function (colWidth, i) {\n    var colSize = props[colWidth];\n    delete attributes[colWidth];\n\n    if (!colSize) {\n      return;\n    }\n\n    var isXs = !i;\n    colClasses.push(isXs ? \"row-cols-\" + colSize : \"row-cols-\" + colWidth + \"-\" + colSize);\n  });\n  var classes = mapToCssModules(classNames(className, noGutters ? 'no-gutters' : null, form ? 'form-row' : 'row', colClasses), cssModule);\n  return /*#__PURE__*/React.createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n};\n\nRow.propTypes = propTypes;\nRow.defaultProps = defaultProps;\nexport default Row;","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { mapToCssModules, tagPropType } from './utils';\nvar propTypes = {\n  tag: tagPropType,\n  inverse: PropTypes.bool,\n  color: PropTypes.string,\n  body: PropTypes.bool,\n  outline: PropTypes.bool,\n  className: PropTypes.string,\n  cssModule: PropTypes.object,\n  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func])\n};\nvar defaultProps = {\n  tag: 'div'\n};\n\nvar Card = function Card(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      color = props.color,\n      body = props.body,\n      inverse = props.inverse,\n      outline = props.outline,\n      Tag = props.tag,\n      innerRef = props.innerRef,\n      attributes = _objectWithoutPropertiesLoose(props, [\"className\", \"cssModule\", \"color\", \"body\", \"inverse\", \"outline\", \"tag\", \"innerRef\"]);\n\n  var classes = mapToCssModules(classNames(className, 'card', inverse ? 'text-white' : false, body ? 'card-body' : false, color ? (outline ? 'border' : 'bg') + \"-\" + color : false), cssModule);\n  return /*#__PURE__*/React.createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    ref: innerRef\n  }));\n};\n\nCard.propTypes = propTypes;\nCard.defaultProps = defaultProps;\nexport default Card;","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { mapToCssModules, tagPropType } from './utils';\nvar propTypes = {\n  tag: tagPropType,\n  listTag: tagPropType,\n  className: PropTypes.string,\n  listClassName: PropTypes.string,\n  cssModule: PropTypes.object,\n  children: PropTypes.node,\n  'aria-label': PropTypes.string\n};\nvar defaultProps = {\n  tag: 'nav',\n  listTag: 'ol',\n  'aria-label': 'breadcrumb'\n};\n\nvar Breadcrumb = function Breadcrumb(props) {\n  var className = props.className,\n      listClassName = props.listClassName,\n      cssModule = props.cssModule,\n      children = props.children,\n      Tag = props.tag,\n      ListTag = props.listTag,\n      label = props['aria-label'],\n      attributes = _objectWithoutPropertiesLoose(props, [\"className\", \"listClassName\", \"cssModule\", \"children\", \"tag\", \"listTag\", \"aria-label\"]);\n\n  var classes = mapToCssModules(classNames(className), cssModule);\n  var listClasses = mapToCssModules(classNames('breadcrumb', listClassName), cssModule);\n  return /*#__PURE__*/React.createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    \"aria-label\": label\n  }), /*#__PURE__*/React.createElement(ListTag, {\n    className: listClasses\n  }, children));\n};\n\nBreadcrumb.propTypes = propTypes;\nBreadcrumb.defaultProps = defaultProps;\nexport default Breadcrumb;","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { mapToCssModules, tagPropType } from './utils';\nvar propTypes = {\n  tag: tagPropType,\n  active: PropTypes.bool,\n  className: PropTypes.string,\n  cssModule: PropTypes.object\n};\nvar defaultProps = {\n  tag: 'li'\n};\n\nvar BreadcrumbItem = function BreadcrumbItem(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      active = props.active,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, [\"className\", \"cssModule\", \"active\", \"tag\"]);\n\n  var classes = mapToCssModules(classNames(className, active ? 'active' : false, 'breadcrumb-item'), cssModule);\n  return /*#__PURE__*/React.createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    \"aria-current\": active ? 'page' : undefined\n  }));\n};\n\nBreadcrumbItem.propTypes = propTypes;\nBreadcrumbItem.defaultProps = defaultProps;\nexport default BreadcrumbItem;","\"use strict\";\n\nvar Sortable = require('./Sortable').default;\n\nmodule.exports = Sortable;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _sortablejs = _interopRequireDefault(require(\"sortablejs\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar store = {\n  nextSibling: null,\n  activeComponent: null\n};\n\nvar Sortable =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Sortable, _Component);\n\n  function Sortable() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Sortable);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Sortable)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"sortable\", null);\n\n    return _this;\n  }\n\n  _createClass(Sortable, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var options = _objectSpread({}, this.props.options);\n\n      ['onChoose', 'onStart', 'onEnd', 'onAdd', 'onUpdate', 'onSort', 'onRemove', 'onFilter', 'onMove', 'onClone'].forEach(function (name) {\n        var eventHandler = options[name];\n\n        options[name] = function () {\n          for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            params[_key2] = arguments[_key2];\n          }\n\n          var evt = params[0];\n\n          if (name === 'onChoose') {\n            store.nextSibling = evt.item.nextElementSibling;\n            store.activeComponent = _this2;\n          } else if ((name === 'onAdd' || name === 'onUpdate') && _this2.props.onChange) {\n            var items = _this2.sortable.toArray();\n\n            var remote = store.activeComponent;\n            var remoteItems = remote.sortable.toArray();\n            var referenceNode = store.nextSibling && store.nextSibling.parentNode !== null ? store.nextSibling : null;\n            evt.from.insertBefore(evt.item, referenceNode);\n\n            if (remote !== _this2) {\n              var remoteOptions = remote.props.options || {};\n\n              if (_typeof(remoteOptions.group) === 'object' && remoteOptions.group.pull === 'clone') {\n                // Remove the node with the same data-reactid\n                evt.item.parentNode.removeChild(evt.item);\n              }\n\n              remote.props.onChange && remote.props.onChange(remoteItems, remote.sortable, evt);\n            }\n\n            _this2.props.onChange && _this2.props.onChange(items, _this2.sortable, evt);\n          }\n\n          if (evt.type === 'move') {\n            var _evt = params[0],\n                originalEvent = params[1];\n            var canMove = eventHandler ? eventHandler(_evt, originalEvent) : true;\n            return canMove;\n          }\n\n          setTimeout(function () {\n            eventHandler && eventHandler(evt);\n          }, 0);\n        };\n      });\n      this.sortable = _sortablejs.default.create(this.node, options);\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      // If onChange is null, it is an UnControlled component\n      // Don't let React re-render it by setting return to false\n      if (!nextProps.onChange) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.sortable) {\n        this.sortable.destroy();\n        this.sortable = null;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$props = this.props,\n          Component = _this$props.tag,\n          options = _this$props.options,\n          onChange = _this$props.onChange,\n          props = _objectWithoutProperties(_this$props, [\"tag\", \"options\", \"onChange\"]);\n\n      return _react.default.createElement(Component, _extends({}, props, {\n        ref: function ref(node) {\n          _this3.node = node;\n        }\n      }));\n    }\n  }]);\n\n  return Sortable;\n}(_react.Component);\n\n_defineProperty(Sortable, \"propTypes\", {\n  options: _propTypes.default.object,\n  onChange: _propTypes.default.func,\n  tag: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]),\n  style: _propTypes.default.object\n});\n\n_defineProperty(Sortable, \"defaultProps\", {\n  options: {},\n  tag: 'div',\n  style: {}\n});\n\nvar _default = Sortable;\nexports.default = _default;","function userAgent(pattern) {\n  if (typeof window !== \"undefined\" && window.navigator) {\n    return !!(/*@__PURE__*/ navigator.userAgent.match(pattern));\n  }\n}\n\nexport const IE11OrLess = userAgent(\n  /(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i\n);\nexport const Edge = userAgent(/Edge/i);\nexport const FireFox = userAgent(/firefox/i);\nexport const Safari =\n  userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nexport const IOS = userAgent(/iP(ad|od|hone)/i);\nexport const ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n","import { IE11OrLess } from \"./browser-info\";\nimport Sortable from \"../../sortable/src/Sortable\";\n\nconst captureMode = {\n  capture: false,\n  passive: false,\n};\n\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction matches(/**HTMLElement*/ el, /**String*/ selector) {\n  if (!selector) return;\n\n  selector[0] === \">\" && (selector = selector.substring(1));\n\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType\n    ? el.host\n    : el.parentNode;\n}\n\nfunction closest(\n  /**HTMLElement*/ el,\n  /**String*/ selector,\n  /**HTMLElement*/ ctx,\n  includeCTX\n) {\n  if (el) {\n    ctx = ctx || document;\n\n    do {\n      if (\n        (selector != null &&\n          (selector[0] === \">\"\n            ? el.parentNode === ctx && matches(el, selector)\n            : matches(el, selector))) ||\n        (includeCTX && el === ctx)\n      ) {\n        return el;\n      }\n\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while ((el = getParentOrHost(el)));\n  }\n\n  return null;\n}\n\nconst R_SPACE = /\\s+/g;\n\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? \"add\" : \"remove\"](name);\n    } else {\n      let className = (\" \" + el.className + \" \")\n        .replace(R_SPACE, \" \")\n        .replace(\" \" + name + \" \", \" \");\n      el.className = (className + (state ? \" \" + name : \"\")).replace(\n        R_SPACE,\n        \" \"\n      );\n    }\n  }\n}\n\nfunction css(el, prop, val) {\n  let style = el && el.style;\n\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, \"\");\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf(\"webkit\") === -1) {\n        prop = \"-webkit-\" + prop;\n      }\n\n      style[prop] = val + (typeof val === \"string\" ? \"\" : \"px\");\n    }\n  }\n}\n\nfunction matrix(el, selfOnly) {\n  let appliedTransforms = \"\";\n  if (typeof el === \"string\") {\n    appliedTransforms = el;\n  } else {\n    do {\n      //@ts-ignore\n      let transform = css(el, \"transform\");\n\n      if (transform && transform !== \"none\") {\n        appliedTransforms = transform + \" \" + appliedTransforms;\n      }\n      /* jshint boss:true */\n    } while (!selfOnly && (el = el.parentNode));\n  }\n\n  const matrixFn =\n    window.DOMMatrix ||\n    window.WebKitCSSMatrix ||\n    //@ts-ignore\n    window.CSSMatrix ||\n    //@ts-ignore\n    window.MSCSSMatrix;\n  /*jshint -W056 */\n  return matrixFn && new matrixFn(appliedTransforms);\n}\n\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    let list = ctx.getElementsByTagName(tagName),\n      i = 0,\n      n = list.length;\n\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n\n    return list;\n  }\n\n  return [];\n}\n\nfunction getWindowScrollingElement() {\n  let scrollingElement = document.scrollingElement;\n\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\nfunction getRect(\n  el,\n  relativeToContainingBlock,\n  relativeToNonStaticParent,\n  undoScale,\n  container\n) {\n  if (!el.getBoundingClientRect && el !== window) return;\n\n  let elRect, top, left, bottom, right, height, width;\n\n  if (el !== window && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n\n  if (\n    (relativeToContainingBlock || relativeToNonStaticParent) &&\n    el !== window\n  ) {\n    // Adjust for translate()\n    container = container || el.parentNode;\n\n    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n    if (!IE11OrLess) {\n      do {\n        if (\n          container &&\n          container.getBoundingClientRect &&\n          //@ts-ignore\n          (css(container, \"transform\") !== \"none\" ||\n            (relativeToNonStaticParent &&\n              //@ts-ignore\n              css(container, \"position\") !== \"static\"))\n        ) {\n          let containerRect = container.getBoundingClientRect();\n\n          // Set relative to edges of padding box of container\n          top -=\n            //@ts-ignore\n            containerRect.top + parseInt(css(container, \"border-top-width\"));\n          left -=\n            //@ts-ignore\n            containerRect.left + parseInt(css(container, \"border-left-width\"));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n\n          break;\n        }\n        /* jshint boss:true */\n      } while ((container = container.parentNode));\n    }\n  }\n\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    //@ts-ignore\n    let elMatrix = matrix(container || el),\n      scaleX = elMatrix && elMatrix.a,\n      scaleY = elMatrix && elMatrix.d;\n\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n\n      width /= scaleX;\n      height /= scaleY;\n\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height,\n  };\n}\n\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\nfunction isScrolledPast(el, elSide, parentSide) {\n  let parent = getParentAutoScrollElement(el, true),\n    //@ts-ignore\n    elSideVal = getRect(el)[elSide];\n\n  /* jshint boss:true */\n  while (parent) {\n    //@ts-ignore\n    let parentSideVal = getRect(parent)[parentSide],\n      visible;\n\n    if (parentSide === \"top\" || parentSide === \"left\") {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n\n    if (!visible) return parent;\n\n    if (parent === getWindowScrollingElement()) break;\n\n    parent = getParentAutoScrollElement(parent, false);\n  }\n\n  return false;\n}\n\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\nfunction getChild(el, childNum, options) {\n  let currentChild = 0,\n    i = 0,\n    children = el.children;\n\n  while (i < children.length) {\n    if (\n      children[i].style.display !== \"none\" &&\n      //@ts-ignore\n      children[i] !== Sortable.ghost &&\n      //@ts-ignore\n      children[i] !== Sortable.dragged &&\n      closest(children[i], options.draggable, el, false)\n    ) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n      currentChild++;\n    }\n\n    i++;\n  }\n  return null;\n}\n\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\nfunction lastChild(el, selector) {\n  let last = el.lastElementChild;\n\n  while (\n    last &&\n    //@ts-ignore\n    (last === Sortable.ghost ||\n      //@ts-ignore\n      css(last, \"display\") === \"none\" ||\n      (selector && !matches(last, selector)))\n  ) {\n    last = last.previousElementSibling;\n  }\n\n  return last || null;\n}\n\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\nfunction index(el, selector) {\n  let index = 0;\n\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n\n  /* jshint boss:true */\n  while ((el = el.previousElementSibling)) {\n    if (\n      el.nodeName.toUpperCase() !== \"TEMPLATE\" &&\n      //@ts-ignore\n      el !== Sortable.clone &&\n      (!selector || matches(el, selector))\n    ) {\n      index++;\n    }\n  }\n\n  return index;\n}\n\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\nfunction getRelativeScrollOffset(el) {\n  let offsetLeft = 0,\n    offsetTop = 0,\n    winScroller = getWindowScrollingElement();\n\n  if (el) {\n    do {\n      //@ts-ignore\n      let elMatrix = matrix(el),\n        scaleX = elMatrix.a,\n        scaleY = elMatrix.d;\n\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n\n  return [offsetLeft, offsetTop];\n}\n\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\nfunction indexOfObject(arr, obj) {\n  for (let i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n  return -1;\n}\n\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n\n  let elem = el;\n  let gotSelf = false;\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (\n      elem.clientWidth < elem.scrollWidth ||\n      elem.clientHeight < elem.scrollHeight\n    ) {\n      //@ts-ignore\n      let elemCSS = css(elem);\n      if (\n        (elem.clientWidth < elem.scrollWidth &&\n          (elemCSS.overflowX == \"auto\" || elemCSS.overflowX == \"scroll\")) ||\n        (elem.clientHeight < elem.scrollHeight &&\n          (elemCSS.overflowY == \"auto\" || elemCSS.overflowY == \"scroll\"))\n      ) {\n        if (!elem.getBoundingClientRect || elem === document.body)\n          return getWindowScrollingElement();\n\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n  } while ((elem = elem.parentNode));\n\n  return getWindowScrollingElement();\n}\n\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (let key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction isRectEqual(rect1, rect2) {\n  return (\n    Math.round(rect1.top) === Math.round(rect2.top) &&\n    Math.round(rect1.left) === Math.round(rect2.left) &&\n    Math.round(rect1.height) === Math.round(rect2.height) &&\n    Math.round(rect1.width) === Math.round(rect2.width)\n  );\n}\n\nlet _throttleTimeout;\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      let args = arguments,\n        _this = this;\n\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\n\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\n\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\n\nfunction clone(el) {\n  //@ts-ignore\n  let Polymer = window.Polymer;\n  //@ts-ignore\n  let $ = window.jQuery || window.Zepto;\n\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\n\nfunction setRect(el, rect) {\n  css(el, \"position\", \"absolute\");\n  css(el, \"top\", rect.top);\n  css(el, \"left\", rect.left);\n  css(el, \"width\", rect.width);\n  css(el, \"height\", rect.height);\n}\n\nfunction unsetRect(el) {\n  css(el, \"position\", \"\");\n  css(el, \"top\", \"\");\n  css(el, \"left\", \"\");\n  css(el, \"width\", \"\");\n  css(el, \"height\", \"\");\n}\n\nconst expando = \"Sortable\" + new Date().getTime();\n\nexport {\n  on,\n  off,\n  matches,\n  getParentOrHost,\n  closest,\n  toggleClass,\n  css,\n  matrix,\n  find,\n  getWindowScrollingElement,\n  getRect,\n  isScrolledPast,\n  getChild,\n  lastChild,\n  index,\n  getRelativeScrollOffset,\n  indexOfObject,\n  getParentAutoScrollElement,\n  extend,\n  isRectEqual,\n  throttle,\n  cancelThrottle,\n  scrollBy,\n  clone,\n  setRect,\n  unsetRect,\n  expando,\n};\n","let plugins = [];\n\nconst defaults = {\n  initializeByDefault: true,\n};\n\nconst pluginManager = {\n  mount(plugin) {\n    // Set default static properties\n    for (let option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n    plugins.push(plugin);\n  },\n  pluginEvent(eventName, sortable, evt) {\n    this.eventCanceled = false;\n    evt.cancel = () => {\n      this.eventCanceled = true;\n    };\n    const eventNameGlobal = eventName + \"Global\";\n    plugins.forEach((plugin) => {\n      if (!sortable[plugin.pluginName]) return;\n      // Fire global events if it exists in this sortable\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal]({ sortable, ...evt });\n      }\n\n      // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n      if (\n        sortable.options[plugin.pluginName] &&\n        sortable[plugin.pluginName][eventName]\n      ) {\n        sortable[plugin.pluginName][eventName]({ sortable, ...evt });\n      }\n    });\n  },\n  initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach((plugin) => {\n      const pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n\n      let initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized;\n\n      // Add default options from plugin\n      Object.assign(defaults, initialized.defaults);\n    });\n\n    for (let option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      let modified = this.modifyOption(\n        sortable,\n        option,\n        sortable.options[option]\n      );\n      if (typeof modified !== \"undefined\") {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties(name, sortable) {\n    let eventProperties = {};\n    plugins.forEach((plugin) => {\n      if (typeof plugin.eventProperties !== \"function\") return;\n      Object.assign(\n        eventProperties,\n        plugin.eventProperties.call(sortable[plugin.pluginName], name)\n      );\n    });\n\n    return eventProperties;\n  },\n  modifyOption(sortable, name, value) {\n    let modifiedValue;\n    plugins.forEach((plugin) => {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return;\n\n      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n      if (\n        plugin.optionListeners &&\n        typeof plugin.optionListeners[name] === \"function\"\n      ) {\n        modifiedValue = plugin.optionListeners[name].call(\n          sortable[plugin.pluginName],\n          value\n        );\n      }\n    });\n\n    return modifiedValue;\n  },\n};\n\nexport default pluginManager;\n","import { expando, IE11OrLess, Edge } from \"../../utils/src\";\nimport PluginManager from \"./PluginManager\";\n\nexport default function dispatchEvent({\n  sortable,\n  rootEl,\n  name,\n  targetEl,\n  cloneEl,\n  toEl,\n  fromEl,\n  oldIndex,\n  newIndex,\n  oldDraggableIndex,\n  newDraggableIndex,\n  originalEvent,\n  putSortable,\n  extraEventProperties,\n}) {\n  sortable = sortable || (rootEl && rootEl[expando]);\n  if (!sortable) return;\n\n  let evt,\n    options = sortable.options,\n    onName = \"on\" + name.charAt(0).toUpperCase() + name.substr(1);\n  // Support for new CustomEvent feature\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true,\n    });\n  } else {\n    evt = document.createEvent(\"Event\");\n    evt.initEvent(name, true, true);\n  }\n\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n  let allEventProperties = {\n    ...extraEventProperties,\n    ...PluginManager.getEventProperties(name, sortable),\n  };\n  for (let option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\n","import { version } from \"../package.json\";\nimport AnimationStateManager from \"./Animation\";\nimport PluginManager from \"./PluginManager\";\nimport dispatchEvent from \"./EventDispatcher\";\n/**\n * @todo import as namespace: import * as utils from \"../../utils/src\"\n */\nimport {\n  on,\n  off,\n  closest,\n  toggleClass,\n  css,\n  matrix,\n  find,\n  getWindowScrollingElement,\n  getRect,\n  isScrolledPast,\n  getChild,\n  lastChild,\n  index,\n  getRelativeScrollOffset,\n  extend,\n  throttle,\n  scrollBy,\n  clone,\n  expando,\n  IE11OrLess,\n  Edge,\n  FireFox,\n  Safari,\n  IOS,\n  ChromeForAndroid,\n} from \"../../utils/src\";\n\nlet pluginEvent = function (\n  eventName,\n  sortable,\n  //@ts-ignore\n  { evt: originalEvent, ...data } = {}\n) {\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, {\n    dragEl,\n    parentEl,\n    ghostEl,\n    rootEl,\n    nextEl,\n    lastDownEl,\n    cloneEl,\n    cloneHidden,\n    dragStarted: moved,\n    putSortable,\n    //@ts-ignore\n    activeSortable: Sortable.active,\n    originalEvent,\n\n    oldIndex,\n    oldDraggableIndex,\n    newIndex,\n    newDraggableIndex,\n\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n\n    cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown() {\n      cloneHidden = false;\n    },\n\n    dispatchSortableEvent(name) {\n      _dispatchEvent({ sortable, name, originalEvent });\n    },\n\n    ...data,\n  });\n};\n\nfunction _dispatchEvent(info) {\n  dispatchEvent({\n    putSortable,\n    cloneEl,\n    targetEl: dragEl,\n    rootEl,\n    oldIndex,\n    oldDraggableIndex,\n    newIndex,\n    newDraggableIndex,\n    ...info,\n  });\n}\n\nlet dragEl,\n  parentEl,\n  ghostEl,\n  rootEl,\n  nextEl,\n  lastDownEl,\n  cloneEl,\n  cloneHidden,\n  oldIndex,\n  newIndex,\n  oldDraggableIndex,\n  newDraggableIndex,\n  activeGroup,\n  putSortable,\n  awaitingDragStarted = false,\n  ignoreNextClick = false,\n  sortables = [],\n  tapEvt,\n  touchEvt,\n  lastDx,\n  lastDy,\n  tapDistanceLeft,\n  tapDistanceTop,\n  moved,\n  lastTarget,\n  lastDirection,\n  pastFirstInvertThresh = false,\n  isCircumstantialInvert = false,\n  targetMoveDistance,\n  // For positioning ghost absolutely\n  ghostRelativeParent,\n  ghostRelativeParentInitialScroll = [], // (left, top)\n  _silent = false,\n  savedInputChecked = [];\n\n/** @const */\nconst documentExists = typeof document !== \"undefined\",\n  PositionGhostAbsolutely = IOS,\n  CSSFloatProperty = Edge || IE11OrLess ? \"cssFloat\" : \"float\",\n  // This will not pass for IE9, because IE9 DnD only works on anchors\n  supportDraggable =\n    documentExists &&\n    !ChromeForAndroid &&\n    !IOS &&\n    \"draggable\" in document.createElement(\"div\"),\n  supportCssPointerEvents = (function () {\n    if (!documentExists) return;\n    // false when <= IE11\n    if (IE11OrLess) {\n      return false;\n    }\n    let el = document.createElement(\"x\");\n    el.style.cssText = \"pointer-events:auto\";\n    return el.style.pointerEvents === \"auto\";\n  })(),\n  _detectDirection = function (el, options) {\n    //@ts-ignore\n    let elCSS = css(el),\n      elWidth =\n        parseInt(elCSS.width) -\n        parseInt(elCSS.paddingLeft) -\n        parseInt(elCSS.paddingRight) -\n        parseInt(elCSS.borderLeftWidth) -\n        parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      //@ts-ignore\n      firstChildCSS = child1 && css(child1),\n      //@ts-ignore\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth =\n        firstChildCSS &&\n        parseInt(firstChildCSS.marginLeft) +\n          parseInt(firstChildCSS.marginRight) +\n          //@ts-ignore\n          getRect(child1).width,\n      secondChildWidth =\n        secondChildCSS &&\n        parseInt(secondChildCSS.marginLeft) +\n          parseInt(secondChildCSS.marginRight) +\n          //@ts-ignore\n          getRect(child2).width;\n\n    if (elCSS.display === \"flex\") {\n      return elCSS.flexDirection === \"column\" ||\n        elCSS.flexDirection === \"column-reverse\"\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    if (elCSS.display === \"grid\") {\n      return elCSS.gridTemplateColumns.split(\" \").length <= 1\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    if (child1 && firstChildCSS.float && firstChildCSS.float !== \"none\") {\n      let touchingSideChild2 =\n        firstChildCSS.float === \"left\" ? \"left\" : \"right\";\n\n      return child2 &&\n        (secondChildCSS.clear === \"both\" ||\n          secondChildCSS.clear === touchingSideChild2)\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    return child1 &&\n      (firstChildCSS.display === \"block\" ||\n        firstChildCSS.display === \"flex\" ||\n        firstChildCSS.display === \"table\" ||\n        firstChildCSS.display === \"grid\" ||\n        (firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === \"none\") ||\n        (child2 &&\n          elCSS[CSSFloatProperty] === \"none\" &&\n          firstChildWidth + secondChildWidth > elWidth))\n      ? \"vertical\"\n      : \"horizontal\";\n  },\n  _dragElInRowColumn = function (dragRect, targetRect, vertical) {\n    let dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n\n    return (\n      dragElS1Opp === targetS1Opp ||\n      dragElS2Opp === targetS2Opp ||\n      dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2\n    );\n  },\n  /**\n   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n   * @param  {Number} x      X position\n   * @param  {Number} y      Y position\n   * @return {HTMLElement}   Element of the first found nearest Sortable\n   */\n  _detectNearestEmptySortable = function (x, y) {\n    let ret;\n    sortables.some((sortable) => {\n      //@ts-ignore\n      if (lastChild(sortable)) return;\n\n      //@ts-ignore\n      let rect = getRect(sortable),\n        threshold = sortable[expando].options.emptyInsertThreshold,\n        insideHorizontally =\n          x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically =\n          y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n      if (threshold && insideHorizontally && insideVertically) {\n        return (ret = sortable);\n      }\n    });\n    return ret;\n  },\n  _prepareGroup = function (options) {\n    function toFn(value, pull) {\n      return function (to, from, dragEl, evt) {\n        let sameGroup =\n          to.options.group.name &&\n          from.options.group.name &&\n          to.options.group.name === from.options.group.name;\n\n        if (value == null && (pull || sameGroup)) {\n          // Default pull value\n          // Default pull and put value if same group\n          return true;\n        } else if (value == null || value === false) {\n          return false;\n        } else if (pull && value === \"clone\") {\n          return value;\n        } else if (typeof value === \"function\") {\n          return toFn(value(to, from, dragEl, evt), pull)(\n            to,\n            from,\n            dragEl,\n            evt\n          );\n        } else {\n          let otherGroup = (pull ? to : from).options.group.name;\n\n          return (\n            value === true ||\n            (typeof value === \"string\" && value === otherGroup) ||\n            (value.join && value.indexOf(otherGroup) > -1)\n          );\n        }\n      };\n    }\n\n    let group = {};\n    let originalGroup = options.group;\n\n    if (!originalGroup || typeof originalGroup != \"object\") {\n      originalGroup = { name: originalGroup };\n    }\n\n    //@ts-ignore\n    group.name = originalGroup.name;\n    //@ts-ignore\n    group.checkPull = toFn(originalGroup.pull, true);\n    //@ts-ignore\n    group.checkPut = toFn(originalGroup.put);\n    //@ts-ignore\n    group.revertClone = originalGroup.revertClone;\n\n    options.group = group;\n  },\n  _hideGhostForTarget = function () {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, \"display\", \"none\");\n    }\n  },\n  _unhideGhostForTarget = function () {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, \"display\", \"\");\n    }\n  };\n\n// #1184 fix - Prevent click event on fallback if dragged but item not changed position\nif (documentExists) {\n  document.addEventListener(\n    \"click\",\n    function (evt) {\n      if (ignoreNextClick) {\n        evt.preventDefault();\n        evt.stopPropagation && evt.stopPropagation();\n        evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n        ignoreNextClick = false;\n        return false;\n      }\n    },\n    true\n  );\n}\n\nlet nearestEmptyInsertDetectEvent = function (evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n    let nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n    if (nearest) {\n      // Create imitation event\n      let event = {};\n      for (let i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n      //@ts-ignore\n      event.target = event.rootEl = nearest;\n      //@ts-ignore\n      event.preventDefault = void 0;\n      //@ts-ignore\n      event.stopPropagation = void 0;\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\n\nlet _checkOutsideTargetEl = function (evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n\n/**\n * @class  Sortable\n * @param  {HTMLElement}  el\n * @param  {Object}       [options]\n */\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw `Sortable: \\`el\\` must be an HTMLElement, not ${{}.toString.call(\n      el\n    )}`;\n  }\n\n  this.el = el; // root element\n  this.options = options = Object.assign({}, options);\n\n  // Export instance\n  el[expando] = this;\n\n  let defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? \">li\" : \">*\",\n    swapThreshold: 1, // percentage; 0 <= x <= 1\n    invertSwap: false, // invert always\n    invertedSwapThreshold: null, // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function () {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: \"sortable-ghost\",\n    chosenClass: \"sortable-chosen\",\n    dragClass: \"sortable-drag\",\n    ignore: \"a, img\",\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function (dataTransfer, dragEl) {\n      dataTransfer.setData(\"Text\", dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: \"data-id\",\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold:\n      (Number.parseInt ? Number : window).parseInt(\n        //@ts-ignore\n        window.devicePixelRatio,\n        10\n      ) || 1,\n    forceFallback: false,\n    fallbackClass: \"sortable-fallback\",\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: { x: 0, y: 0 },\n    supportPointer:\n      //@ts-ignore\n      Sortable.supportPointer !== false && \"PointerEvent\" in window,\n    emptyInsertThreshold: 5,\n  };\n\n  //@ts-ignore\n  PluginManager.initializePlugins(this, el, defaults);\n\n  // Set default options\n  for (let name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n\n  _prepareGroup(options);\n\n  // Bind all private methods\n  for (let fn in this) {\n    if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n      this[fn] = this[fn].bind(this);\n    }\n  }\n\n  // Setup drag mode\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  }\n\n  // Bind events\n  if (options.supportPointer) {\n    on(el, \"pointerdown\", this._onTapStart);\n  } else {\n    on(el, \"mousedown\", this._onTapStart);\n    on(el, \"touchstart\", this._onTapStart);\n  }\n\n  if (this.nativeDraggable) {\n    on(el, \"dragover\", this);\n    on(el, \"dragenter\", this);\n  }\n\n  sortables.push(this.el);\n\n  // Restore sorting\n  options.store &&\n    options.store.get &&\n    this.sort(options.store.get(this) || []);\n\n  // Add animation state manager\n  Object.assign(this, AnimationStateManager());\n}\n\nSortable.prototype = /** @lends Sortable.prototype */ {\n  constructor: Sortable,\n\n  _isOutsideThisEl: function (target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n\n  _getDirection: function (evt, target) {\n    return typeof this.options.direction === \"function\"\n      ? this.options.direction.call(this, evt, target, dragEl)\n      : this.options.direction;\n  },\n\n  _onTapStart: function (/** Event|TouchEvent */ evt) {\n    if (!evt.cancelable) return;\n    let _this = this,\n      el = this.el,\n      options = this.options,\n      preventOnFilter = options.preventOnFilter,\n      type = evt.type,\n      touch =\n        (evt.touches && evt.touches[0]) ||\n        (evt.pointerType && evt.pointerType === \"touch\" && evt),\n      target = (touch || evt).target,\n      originalTarget =\n        (evt.target.shadowRoot &&\n          ((evt.path && evt.path[0]) ||\n            (evt.composedPath && evt.composedPath()[0]))) ||\n        target,\n      filter = options.filter;\n\n    _saveInputCheckedState(el);\n\n    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n    if (dragEl) {\n      return;\n    }\n\n    if (\n      (/mousedown|pointerdown/.test(type) && evt.button !== 0) ||\n      options.disabled\n    ) {\n      return; // only left button and enabled\n    }\n\n    // cancel dnd if original target is content editable\n    if (originalTarget.isContentEditable) {\n      return;\n    }\n\n    // Safari ignores further event handling after mousedown\n    if (\n      !this.nativeDraggable &&\n      Safari &&\n      target &&\n      target.tagName.toUpperCase() === \"SELECT\"\n    ) {\n      return;\n    }\n\n    target = closest(target, options.draggable, el, false);\n\n    if (target && target.animated) {\n      return;\n    }\n\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    }\n\n    // Get the index of the dragged element within its parent\n    //@ts-ignore\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable);\n\n    // Check filter\n    if (typeof filter === \"function\") {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: \"filter\",\n          targetEl: target,\n          toEl: el,\n          fromEl: el,\n        });\n        pluginEvent(\"filter\", _this, { evt });\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(\",\").some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: \"filter\",\n            targetEl: target,\n            fromEl: el,\n            toEl: el,\n          });\n          pluginEvent(\"filter\", _this, { evt });\n          return true;\n        }\n      });\n\n      if (filter) {\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    }\n\n    // Prepare `dragstart`\n    this._prepareDragStart(evt, touch, target);\n  },\n\n  _prepareDragStart: function (\n    /** Event */ evt,\n    /** Touch */ touch,\n    /** HTMLElement */ target\n  ) {\n    let _this = this,\n      el = _this.el,\n      options = _this.options,\n      ownerDocument = el.ownerDocument,\n      dragStartFn;\n\n    if (target && !dragEl && target.parentNode === el) {\n      //@ts-ignore\n      let dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n\n      //@ts-ignore\n      Sortable.dragged = dragEl;\n\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY,\n      };\n\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n\n      dragEl.style[\"will-change\"] = \"all\";\n\n      dragStartFn = function () {\n        pluginEvent(\"delayEnded\", _this, { evt });\n        //@ts-ignore\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n          return;\n        }\n        // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n        _this._disableDelayedDragEvents();\n\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        }\n\n        // Bind the events: dragstart/dragend\n        _this._triggerDragStart(evt, touch);\n\n        // Drag start event\n        _dispatchEvent({\n          sortable: _this,\n          name: \"choose\",\n          originalEvent: evt,\n        });\n\n        // Chosen item\n        toggleClass(dragEl, options.chosenClass, true);\n      };\n\n      // Disable \"draggable\"\n      options.ignore.split(\",\").forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n\n      on(ownerDocument, \"dragover\", nearestEmptyInsertDetectEvent);\n      on(ownerDocument, \"mousemove\", nearestEmptyInsertDetectEvent);\n      on(ownerDocument, \"touchmove\", nearestEmptyInsertDetectEvent);\n\n      on(ownerDocument, \"mouseup\", _this._onDrop);\n      on(ownerDocument, \"touchend\", _this._onDrop);\n      on(ownerDocument, \"touchcancel\", _this._onDrop);\n\n      // Make dragEl draggable (must be before delay for FireFox)\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n\n      pluginEvent(\"delayStart\", this, { evt });\n\n      // Delay is impossible for native DnD in Edge or IE\n      if (\n        options.delay &&\n        (!options.delayOnTouchOnly || touch) &&\n        (!this.nativeDraggable || !(Edge || IE11OrLess))\n      ) {\n        //@ts-ignore\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n          return;\n        }\n        // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n        on(ownerDocument, \"mouseup\", _this._disableDelayedDrag);\n        on(ownerDocument, \"touchend\", _this._disableDelayedDrag);\n        on(ownerDocument, \"touchcancel\", _this._disableDelayedDrag);\n        on(ownerDocument, \"mousemove\", _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, \"touchmove\", _this._delayedDragTouchMoveHandler);\n        options.supportPointer &&\n          on(ownerDocument, \"pointermove\", _this._delayedDragTouchMoveHandler);\n\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n\n  _delayedDragTouchMoveHandler: function (/** TouchEvent|PointerEvent **/ e) {\n    let touch = e.touches ? e.touches[0] : e;\n    if (\n      Math.max(\n        Math.abs(touch.clientX - this._lastX),\n        Math.abs(touch.clientY - this._lastY)\n      ) >=\n      Math.floor(\n        this.options.touchStartThreshold /\n          ((this.nativeDraggable && window.devicePixelRatio) || 1)\n      )\n    ) {\n      this._disableDelayedDrag();\n    }\n  },\n\n  _disableDelayedDrag: function () {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n\n    this._disableDelayedDragEvents();\n  },\n\n  _disableDelayedDragEvents: function () {\n    let ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, \"mouseup\", this._disableDelayedDrag);\n    off(ownerDocument, \"touchend\", this._disableDelayedDrag);\n    off(ownerDocument, \"touchcancel\", this._disableDelayedDrag);\n    off(ownerDocument, \"mousemove\", this._delayedDragTouchMoveHandler);\n    off(ownerDocument, \"touchmove\", this._delayedDragTouchMoveHandler);\n    off(ownerDocument, \"pointermove\", this._delayedDragTouchMoveHandler);\n  },\n\n  _triggerDragStart: function (/** Event */ evt, /** Touch */ touch) {\n    touch = touch || (evt.pointerType == \"touch\" && evt);\n\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, \"pointermove\", this._onTouchMove);\n      } else if (touch) {\n        on(document, \"touchmove\", this._onTouchMove);\n      } else {\n        on(document, \"mousemove\", this._onTouchMove);\n      }\n    } else {\n      on(dragEl, \"dragend\", this);\n      on(rootEl, \"dragstart\", this._onDragStart);\n    }\n\n    try {\n      //@ts-ignore\n      if (document.selection) {\n        // Timeout neccessary for IE9\n        _nextTick(function () {\n          //@ts-ignore\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n\n  _dragStarted: function (fallback, evt) {\n    let _this = this;\n    awaitingDragStarted = false;\n    if (rootEl && dragEl) {\n      pluginEvent(\"dragStarted\", this, { evt });\n\n      if (this.nativeDraggable) {\n        on(document, \"dragover\", _checkOutsideTargetEl);\n      }\n      let options = this.options;\n\n      // Apply effect\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n\n      //@ts-ignore\n      Sortable.active = this;\n\n      fallback && this._appendGhost();\n\n      // Drag start event\n      _dispatchEvent({\n        sortable: this,\n        name: \"start\",\n        originalEvent: evt,\n      });\n    } else {\n      this._nulling();\n    }\n  },\n\n  _emulateDragOver: function () {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n\n      _hideGhostForTarget();\n\n      let target = document.elementFromPoint(\n        touchEvt.clientX,\n        touchEvt.clientY\n      );\n      let parent = target;\n\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(\n          touchEvt.clientX,\n          touchEvt.clientY\n        );\n        if (target === parent) break;\n        parent = target;\n      }\n\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            let inserted;\n\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent,\n            });\n\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n\n          target = parent; // store last element\n        } while (\n          /* jshint boss:true */\n          //@ts-ignore\n          (parent = parent.parentNode)\n        );\n      }\n\n      _unhideGhostForTarget();\n    }\n  },\n\n  _onTouchMove: function (/**TouchEvent*/ evt) {\n    if (tapEvt) {\n      let options = this.options,\n        fallbackTolerance = options.fallbackTolerance,\n        fallbackOffset = options.fallbackOffset,\n        touch = evt.touches ? evt.touches[0] : evt,\n        ghostMatrix = ghostEl && matrix(ghostEl, true),\n        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n        relativeScrollOffset =\n          PositionGhostAbsolutely &&\n          ghostRelativeParent &&\n          getRelativeScrollOffset(ghostRelativeParent),\n        dx =\n          (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) +\n          (relativeScrollOffset\n            ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]\n            : 0) /\n            (scaleX || 1),\n        dy =\n          (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) +\n          (relativeScrollOffset\n            ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]\n            : 0) /\n            (scaleY || 1);\n\n      // only set the status to dragging, when we are actually dragging\n      //@ts-ignore\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (\n          fallbackTolerance &&\n          Math.max(\n            Math.abs(touch.clientX - this._lastX),\n            Math.abs(touch.clientY - this._lastY)\n          ) < fallbackTolerance\n        ) {\n          return;\n        }\n        this._onDragStart(evt, true);\n      }\n\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy,\n          };\n        }\n\n        let cssMatrix = `matrix(${ghostMatrix.a},${ghostMatrix.b},${ghostMatrix.c},${ghostMatrix.d},${ghostMatrix.e},${ghostMatrix.f})`;\n\n        css(ghostEl, \"webkitTransform\", cssMatrix);\n        css(ghostEl, \"mozTransform\", cssMatrix);\n        css(ghostEl, \"msTransform\", cssMatrix);\n        css(ghostEl, \"transform\", cssMatrix);\n\n        lastDx = dx;\n        lastDy = dy;\n\n        touchEvt = touch;\n      }\n\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n\n  _appendGhost: function () {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      let container = this.options.fallbackOnBody ? document.body : rootEl,\n        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n        options = this.options;\n\n      // Position absolutely\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n\n        while (\n          //@ts-ignore\n          css(ghostRelativeParent, \"position\") === \"static\" &&\n          //@ts-ignore\n          css(ghostRelativeParent, \"transform\") === \"none\" &&\n          ghostRelativeParent !== document\n        ) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n\n        if (\n          ghostRelativeParent !== document.body &&\n          ghostRelativeParent !== document.documentElement\n        ) {\n          if (ghostRelativeParent === document)\n            ghostRelativeParent = getWindowScrollingElement();\n\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(\n          ghostRelativeParent\n        );\n      }\n\n      ghostEl = dragEl.cloneNode(true);\n\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n\n      css(ghostEl, \"transition\", \"\");\n      css(ghostEl, \"transform\", \"\");\n\n      css(ghostEl, \"box-sizing\", \"border-box\");\n      css(ghostEl, \"margin\", 0);\n      css(ghostEl, \"top\", rect.top);\n      css(ghostEl, \"left\", rect.left);\n      css(ghostEl, \"width\", rect.width);\n      css(ghostEl, \"height\", rect.height);\n      css(ghostEl, \"opacity\", \"0.8\");\n      css(ghostEl, \"position\", PositionGhostAbsolutely ? \"absolute\" : \"fixed\");\n      css(ghostEl, \"zIndex\", \"100000\");\n      css(ghostEl, \"pointerEvents\", \"none\");\n\n      //@ts-ignore\n      Sortable.ghost = ghostEl;\n\n      container.appendChild(ghostEl);\n\n      // Set transform-origin\n      css(\n        ghostEl,\n        \"transform-origin\",\n        (tapDistanceLeft / parseInt(ghostEl.style.width)) * 100 +\n          \"% \" +\n          (tapDistanceTop / parseInt(ghostEl.style.height)) * 100 +\n          \"%\"\n      );\n    }\n  },\n\n  _onDragStart: function (/**Event*/ evt, /**boolean*/ fallback) {\n    let _this = this;\n    let dataTransfer = evt.dataTransfer;\n    let options = _this.options;\n\n    pluginEvent(\"dragStart\", this, { evt });\n    //@ts-ignore\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n      return;\n    }\n\n    pluginEvent(\"setupClone\", this);\n    //@ts-ignore\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n\n      cloneEl.draggable = false;\n      cloneEl.style[\"will-change\"] = \"\";\n\n      this._hideClone();\n\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      //@ts-ignore\n      Sortable.clone = cloneEl;\n    }\n\n    // #1143: IFrame support workaround\n    _this.cloneId = _nextTick(function () {\n      pluginEvent(\"clone\", _this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n      _this._hideClone();\n\n      _dispatchEvent({\n        sortable: _this,\n        name: \"clone\",\n      });\n    });\n\n    !fallback && toggleClass(dragEl, options.dragClass, true);\n\n    // Set proper drop events\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, \"mouseup\", _this._onDrop);\n      off(document, \"touchend\", _this._onDrop);\n      off(document, \"touchcancel\", _this._onDrop);\n\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = \"move\";\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n\n      on(document, \"drop\", _this);\n\n      // #1276 fix:\n      css(dragEl, \"transform\", \"translateZ(0)\");\n    }\n\n    awaitingDragStarted = true;\n\n    _this._dragStartId = _nextTick(\n      _this._dragStarted.bind(_this, fallback, evt)\n    );\n    on(document, \"selectstart\", _this);\n\n    moved = true;\n\n    if (Safari) {\n      css(document.body, \"user-select\", \"none\");\n    }\n  },\n\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function (/**Event*/ evt) {\n    let el = this.el,\n      target = evt.target,\n      dragRect,\n      targetRect,\n      revert,\n      options = this.options,\n      group = options.group,\n      //@ts-ignore\n      activeSortable = Sortable.active,\n      isOwner = activeGroup === group,\n      canSort = options.sort,\n      fromSortable = putSortable || activeSortable,\n      vertical,\n      _this = this,\n      completedFired = false;\n\n    if (_silent) return;\n\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, {\n        evt,\n        isOwner,\n        axis: vertical ? \"vertical\" : \"horizontal\",\n        revert,\n        dragRect,\n        targetRect,\n        canSort,\n        fromSortable,\n        target,\n        completed,\n        onMove(target, after) {\n          return onMove(\n            rootEl,\n            el,\n            dragEl,\n            dragRect,\n            target,\n            //@ts-ignore\n            getRect(target),\n            evt,\n            after\n          );\n        },\n        changed,\n        ...extra,\n      });\n    }\n\n    // Capture animation state\n    function capture() {\n      //@ts-ignore\n      dragOverEvent(\"dragOverAnimationCapture\");\n\n      _this.captureAnimationState();\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    }\n\n    // Return invocation when dragEl is inserted (or completed)\n    function completed(insertion) {\n      dragOverEvent(\"dragOverCompleted\", { insertion });\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(\n            dragEl,\n            putSortable\n              ? putSortable.options.ghostClass\n              : activeSortable.options.ghostClass,\n            false\n          );\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n\n        //@ts-ignore\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n          //@ts-ignore\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        }\n\n        // Animation\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n        _this.animateAll(function () {\n          //@ts-ignore\n          dragOverEvent(\"dragOverAnimationComplete\");\n          _this._ignoreWhileAnimating = null;\n        });\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      }\n\n      // Null lastTarget if it is not inside a previously swapped element\n      if (\n        (target === dragEl && !dragEl.animated) ||\n        (target === el && !target.animated)\n      ) {\n        lastTarget = null;\n      }\n\n      // no bubbling and not fallback\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n\n        // Do not detect for empty insert if already inserted\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n\n      return (completedFired = true);\n    }\n\n    // Call when dragEl has been inserted\n    function changed() {\n      //@ts-ignore\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n      _dispatchEvent({\n        sortable: _this,\n        name: \"change\",\n        toEl: el,\n        newIndex,\n        newDraggableIndex,\n        originalEvent: evt,\n      });\n    }\n\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n\n    target = closest(target, options.draggable, el, true);\n\n    //@ts-ignore\n    dragOverEvent(\"dragOver\");\n    //@ts-ignore\n    if (Sortable.eventCanceled) return completedFired;\n\n    if (\n      dragEl.contains(evt.target) ||\n      (target.animated && target.animatingX && target.animatingY) ||\n      _this._ignoreWhileAnimating === target\n    ) {\n      return completed(false);\n    }\n\n    ignoreNextClick = false;\n\n    if (\n      activeSortable &&\n      !options.disabled &&\n      (isOwner\n        ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n        : putSortable === this ||\n          ((this.lastPutMode = activeGroup.checkPull(\n            this,\n            activeSortable,\n            dragEl,\n            evt\n          )) &&\n            group.checkPut(this, activeSortable, dragEl, evt)))\n    ) {\n      vertical = this._getDirection(evt, target) === \"vertical\";\n\n      //@ts-ignore\n      dragRect = getRect(dragEl);\n\n      //@ts-ignore\n      dragOverEvent(\"dragOverValid\");\n      //@ts-ignore\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (revert) {\n        parentEl = rootEl; // actualization\n        capture();\n\n        this._hideClone();\n\n        //@ts-ignore\n        dragOverEvent(\"revert\");\n\n        //@ts-ignore\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n\n        return completed(true);\n      }\n\n      let elLastChild = lastChild(el, options.draggable);\n\n      if (\n        !elLastChild ||\n        (_ghostIsLast(evt, vertical, this) && !elLastChild.animated)\n      ) {\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        }\n\n        // assign target only if condition is true\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n\n        if (target) {\n          //@ts-ignore\n          targetRect = getRect(target);\n        }\n\n        if (\n          onMove(\n            rootEl,\n            el,\n            dragEl,\n            dragRect,\n            target,\n            targetRect,\n            evt,\n            !!target\n          ) !== false\n        ) {\n          capture();\n          el.appendChild(dragEl);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        //@ts-ignore\n        targetRect = getRect(target);\n        let direction = 0,\n          targetBeforeFirstSwap,\n          differentLevel = dragEl.parentNode !== el,\n          differentRowCol = !_dragElInRowColumn(\n            (dragEl.animated && dragEl.toRect) || dragRect,\n            (target.animated && target.toRect) || targetRect,\n            vertical\n          ),\n          side1 = vertical ? \"top\" : \"left\",\n          scrolledPastTop =\n            isScrolledPast(target, \"top\", \"top\") ||\n            isScrolledPast(dragEl, \"top\", \"top\"),\n          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert =\n            (!differentRowCol && options.invertSwap) || differentLevel;\n        }\n\n        direction = _getSwapDirection(\n          evt,\n          target,\n          targetRect,\n          vertical,\n          differentRowCol ? 1 : options.swapThreshold,\n          options.invertedSwapThreshold == null\n            ? options.swapThreshold\n            : options.invertedSwapThreshold,\n          isCircumstantialInvert,\n          lastTarget === target\n        );\n\n        let sibling;\n\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          //@ts-ignore\n          let dragIndex = index(dragEl);\n\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (\n            sibling &&\n            //@ts-ignore\n            (css(sibling, \"display\") === \"none\" || sibling === ghostEl)\n          );\n        }\n        // If dragEl is already beside target: Do not insert\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n\n        lastTarget = target;\n\n        lastDirection = direction;\n\n        let nextSibling = target.nextElementSibling,\n          after = false;\n\n        after = direction === 1;\n\n        let moveVector = onMove(\n          rootEl,\n          el,\n          dragEl,\n          dragRect,\n          target,\n          targetRect,\n          evt,\n          after\n        );\n\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n\n          _silent = true;\n          setTimeout(_unsilent, 30);\n\n          capture();\n\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(\n              dragEl,\n              after ? nextSibling : target\n            );\n          }\n\n          // Undo chrome's scroll adjustment (has no effect on other browsers)\n          if (scrolledPastTop) {\n            scrollBy(\n              scrolledPastTop,\n              0,\n              scrollBefore - scrolledPastTop.scrollTop\n            );\n          }\n\n          parentEl = dragEl.parentNode; // actualization\n\n          // must be done before animation\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(\n              //@ts-ignore\n              targetBeforeFirstSwap - getRect(target)[side1]\n            );\n          }\n          changed();\n\n          return completed(true);\n        }\n      }\n\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n\n    return false;\n  },\n\n  _ignoreWhileAnimating: null,\n\n  _offMoveEvents: function () {\n    off(document, \"mousemove\", this._onTouchMove);\n    off(document, \"touchmove\", this._onTouchMove);\n    off(document, \"pointermove\", this._onTouchMove);\n    off(document, \"dragover\", nearestEmptyInsertDetectEvent);\n    off(document, \"mousemove\", nearestEmptyInsertDetectEvent);\n    off(document, \"touchmove\", nearestEmptyInsertDetectEvent);\n  },\n\n  _offUpEvents: function () {\n    let ownerDocument = this.el.ownerDocument;\n\n    off(ownerDocument, \"mouseup\", this._onDrop);\n    off(ownerDocument, \"touchend\", this._onDrop);\n    off(ownerDocument, \"pointerup\", this._onDrop);\n    off(ownerDocument, \"touchcancel\", this._onDrop);\n    off(document, \"selectstart\", this);\n  },\n\n  _onDrop: function (/**Event*/ evt) {\n    let el = this.el,\n      options = this.options;\n\n    // Get the index of the dragged element within its parent\n    //@ts-ignore\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    pluginEvent(\"drop\", this, {\n      evt,\n    });\n\n    parentEl = dragEl && dragEl.parentNode;\n\n    // Get again after plugin event\n    //@ts-ignore\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    //@ts-ignore\n    if (Sortable.eventCanceled) {\n      this._nulling();\n      return;\n    }\n\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n\n    clearInterval(this._loopId);\n\n    clearTimeout(this._dragStartTimer);\n\n    _cancelNextTick(this.cloneId);\n    _cancelNextTick(this._dragStartId);\n\n    // Unbind events\n    if (this.nativeDraggable) {\n      off(document, \"drop\", this);\n      off(el, \"dragstart\", this._onDragStart);\n    }\n    this._offMoveEvents();\n    this._offUpEvents();\n\n    if (Safari) {\n      css(document.body, \"user-select\", \"\");\n    }\n\n    css(dragEl, \"transform\", \"\");\n\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n      if (\n        rootEl === parentEl ||\n        (putSortable && putSortable.lastPutMode !== \"clone\")\n      ) {\n        // Remove clone(s)\n        cloneEl &&\n          cloneEl.parentNode &&\n          cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, \"dragend\", this);\n        }\n\n        _disableDraggable(dragEl);\n        dragEl.style[\"will-change\"] = \"\";\n\n        // Remove classes\n        // ghostClass is added in dragStarted\n        if (moved && !awaitingDragStarted) {\n          toggleClass(\n            dragEl,\n            putSortable\n              ? putSortable.options.ghostClass\n              : this.options.ghostClass,\n            false\n          );\n        }\n        toggleClass(dragEl, this.options.chosenClass, false);\n\n        // Drag stop event\n        _dispatchEvent({\n          sortable: this,\n          name: \"unchoose\",\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt,\n        });\n\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: \"add\",\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt,\n            });\n\n            // Remove event\n            _dispatchEvent({\n              sortable: this,\n              name: \"remove\",\n              toEl: parentEl,\n              originalEvent: evt,\n            });\n\n            // drag from one list and drop into another\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: \"sort\",\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt,\n            });\n\n            _dispatchEvent({\n              sortable: this,\n              name: \"sort\",\n              toEl: parentEl,\n              originalEvent: evt,\n            });\n          }\n\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: \"update\",\n                toEl: parentEl,\n                originalEvent: evt,\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: \"sort\",\n                toEl: parentEl,\n                originalEvent: evt,\n              });\n            }\n          }\n        }\n\n        //@ts-ignore\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n\n          _dispatchEvent({\n            sortable: this,\n            name: \"end\",\n            toEl: parentEl,\n            originalEvent: evt,\n          });\n\n          // Save sorting\n          this.save();\n        }\n      }\n    }\n    this._nulling();\n  },\n\n  _nulling: function () {\n    pluginEvent(\"nulling\", this);\n    //@ts-ignore\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n\n  handleEvent: function (/**Event*/ evt) {\n    switch (evt.type) {\n      case \"drop\":\n      case \"dragend\":\n        this._onDrop(evt);\n        break;\n\n      case \"dragenter\":\n      case \"dragover\":\n        if (dragEl) {\n          this._onDragOver(evt);\n          _globalDragOver(evt);\n        }\n        break;\n\n      case \"selectstart\":\n        evt.preventDefault();\n        break;\n    }\n  },\n\n  /**\n   * Serializes the item into an array of string.\n   * @returns {String[]}\n   */\n  toArray: function () {\n    let order = [],\n      el,\n      children = this.el.children,\n      i = 0,\n      n = children.length,\n      options = this.options;\n\n    for (; i < n; i++) {\n      el = children[i];\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n\n    return order;\n  },\n\n  /**\n   * Sorts the elements according to the array.\n   * @param  {String[]}  order  order of the items\n   */\n  sort: function (order) {\n    let items = {},\n      rootEl = this.el;\n\n    this.toArray().forEach(function (id, i) {\n      let el = rootEl.children[i];\n\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n  },\n\n  /**\n   * Save the current sorting\n   */\n  save: function () {\n    let store = this.options.store;\n    store && store.set && store.set(this);\n  },\n\n  /**\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n   * @param   {HTMLElement}  el\n   * @param   {String}       [selector]  default: `options.draggable`\n   * @returns {HTMLElement|null}\n   */\n  closest: function (el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n\n  /**\n   * Set/get option\n   * @param   {string} name\n   * @param   {*}      [value]\n   * @returns {*}\n   */\n  option: function (name, value) {\n    let options = this.options;\n\n    if (value === void 0) {\n      return options[name];\n    } else {\n      let modifiedValue = PluginManager.modifyOption(this, name, value);\n      if (typeof modifiedValue !== \"undefined\") {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n\n      if (name === \"group\") {\n        _prepareGroup(options);\n      }\n    }\n  },\n\n  /**\n   * Destroy\n   */\n  destroy: function () {\n    pluginEvent(\"destroy\", this);\n    let el = this.el;\n\n    el[expando] = null;\n\n    off(el, \"mousedown\", this._onTapStart);\n    off(el, \"touchstart\", this._onTapStart);\n    off(el, \"pointerdown\", this._onTapStart);\n\n    if (this.nativeDraggable) {\n      off(el, \"dragover\", this);\n      off(el, \"dragenter\", this);\n    }\n    // Remove draggable attributes\n    Array.prototype.forEach.call(el.querySelectorAll(\"[draggable]\"), function (\n      el\n    ) {\n      el.removeAttribute(\"draggable\");\n    });\n\n    this._onDrop();\n\n    this._disableDelayedDragEvents();\n\n    sortables.splice(sortables.indexOf(this.el), 1);\n\n    this.el = el = null;\n  },\n\n  _hideClone: function () {\n    if (!cloneHidden) {\n      pluginEvent(\"hideClone\", this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      css(cloneEl, \"display\", \"none\");\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n      cloneHidden = true;\n    }\n  },\n\n  _showClone: function (putSortable) {\n    if (putSortable.lastPutMode !== \"clone\") {\n      this._hideClone();\n      return;\n    }\n\n    if (cloneHidden) {\n      pluginEvent(\"showClone\", this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      // show clone at dragEl or original position\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n\n      css(cloneEl, \"display\", \"\");\n      cloneHidden = false;\n    }\n  },\n};\n\nfunction _globalDragOver(/**Event*/ evt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = \"move\";\n  }\n  evt.cancelable && evt.preventDefault();\n}\n\nfunction onMove(\n  fromEl,\n  toEl,\n  dragEl,\n  dragRect,\n  targetEl,\n  targetRect,\n  originalEvent,\n  willInsertAfter\n) {\n  let evt,\n    sortable = fromEl[expando],\n    onMoveFn = sortable.options.onMove,\n    retVal;\n  // Support for new CustomEvent feature\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(\"move\", {\n      bubbles: true,\n      cancelable: true,\n    });\n  } else {\n    evt = document.createEvent(\"Event\");\n    evt.initEvent(\"move\", true, true);\n  }\n\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  //@ts-ignore\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n\n  evt.originalEvent = originalEvent;\n\n  fromEl.dispatchEvent(evt);\n\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n\n  return retVal;\n}\n\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\n\nfunction _unsilent() {\n  _silent = false;\n}\n\nfunction _ghostIsLast(evt, vertical, sortable) {\n  //@ts-ignore\n  let rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  const spacer = 10;\n\n  return vertical\n    ? evt.clientX > rect.right + spacer ||\n        (evt.clientX <= rect.right &&\n          evt.clientY > rect.bottom &&\n          evt.clientX >= rect.left)\n    : (evt.clientX > rect.right && evt.clientY > rect.top) ||\n        (evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer);\n}\n\nfunction _getSwapDirection(\n  evt,\n  target,\n  targetRect,\n  vertical,\n  swapThreshold,\n  invertedSwapThreshold,\n  invertSwap,\n  isLastTarget\n) {\n  let mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n    targetLength = vertical ? targetRect.height : targetRect.width,\n    targetS1 = vertical ? targetRect.top : targetRect.left,\n    targetS2 = vertical ? targetRect.bottom : targetRect.right,\n    invert = false;\n\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (\n        !pastFirstInvertThresh &&\n        (lastDirection === 1\n          ? mouseOnAxis > targetS1 + (targetLength * invertedSwapThreshold) / 2\n          : mouseOnAxis < targetS2 - (targetLength * invertedSwapThreshold) / 2)\n      ) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (\n          lastDirection === 1\n            ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n            : mouseOnAxis > targetS2 - targetMoveDistance\n        ) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (\n        mouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold)) / 2 &&\n        mouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold)) / 2\n      ) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n\n  invert = invert || invertSwap;\n\n  if (invert) {\n    // Invert of regular\n    if (\n      mouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold) / 2 ||\n      mouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold) / 2\n    ) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Gets the direction dragEl must be swapped relative to target in order to make it\n * seem that dragEl has been \"inserted\" into that element's position\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n * @return {Number}                   Direction dragEl must be swapped\n */\nfunction _getInsertDirection(target) {\n  //@ts-ignore\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n\n/**\n * Generate id\n * @param   {HTMLElement} el\n * @returns {String}\n * @private\n */\nfunction _generateId(el) {\n  let str = el.tagName + el.className + el.src + el.href + el.textContent,\n    i = str.length,\n    sum = 0;\n\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n\n  return sum.toString(36);\n}\n\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n\n  let inputs = root.getElementsByTagName(\"input\");\n  let idx = inputs.length;\n\n  while (idx--) {\n    let el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\n\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\n\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n}\n\n// Fixed #973:\nif (documentExists) {\n  on(document, \"touchmove\", function (evt) {\n    //@ts-ignore\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n}\n\n// Export utils\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function (el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild,\n};\n\n/**\n * Get the Sortable instance of an element\n * @param  {HTMLElement} element The element\n * @return {Sortable|undefined}         The instance of Sortable\n */\nSortable.get = function (element) {\n  return element[expando];\n};\n\n/**\n * Mount a plugin to Sortable\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\n */\nSortable.mount = function (...plugins) {\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n\n  plugins.forEach((plugin) => {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw `Sortable: Mounted plugin must be a constructor function, not ${{}.toString.call(\n        plugin\n      )}`;\n    }\n    if (plugin.utils) Sortable.utils = { ...Sortable.utils, ...plugin.utils };\n\n    PluginManager.mount(plugin);\n  });\n};\n\n/**\n * Create sortable instance\n * @param {HTMLElement}  el\n * @param {Object}      [options]\n */\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n};\n\n// Export\nSortable.version = version;\n\nexport default Sortable;\n","import { toggleClass, index } from \"../../../utils/src\";\n\nlet lastSwapEl;\n\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: \"sortable-swap-highlight\",\n    };\n  }\n\n  Swap.prototype = {\n    dragStart({ dragEl }) {\n      lastSwapEl = dragEl;\n    },\n    dragOverValid({\n      completed,\n      target,\n      onMove,\n      activeSortable,\n      changed,\n      cancel,\n    }) {\n      if (!activeSortable.options.swap) return;\n      let el = this.sortable.el,\n        options = this.options;\n      if (target && target !== el) {\n        let prevSwapEl = lastSwapEl;\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n      changed();\n\n      completed(true);\n      cancel();\n    },\n    drop({ activeSortable, putSortable, dragEl }) {\n      let toSortable = putSortable || this.sortable;\n      let options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n      if (\n        lastSwapEl &&\n        (options.swap || (putSortable && putSortable.options.swap))\n      ) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable)\n            activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling() {\n      lastSwapEl = null;\n    },\n  };\n\n  return Object.assign(Swap, {\n    pluginName: \"swap\",\n    eventProperties() {\n      return {\n        swapItem: lastSwapEl,\n      };\n    },\n  });\n}\n\nfunction swapNodes(n1, n2) {\n  let p1 = n1.parentNode,\n    p2 = n2.parentNode,\n    i1,\n    i2;\n\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n\n  //@ts-ignore\n  i1 = index(n1);\n  //@ts-ignore\n  i2 = index(n2);\n\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\n\nexport default SwapPlugin;\n","import {\n  getRect,\n  css,\n  matrix,\n  isRectEqual,\n  indexOfObject,\n} from \"../../utils/src\";\nimport * as Sortable from \"./Sortable\";\n\nexport default function AnimationStateManager() {\n  let animationStates = [],\n    animationCallbackId;\n\n  return {\n    captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      let children = [].slice.call(this.el.children);\n\n      children.forEach((child) => {\n        //@ts-ignore\n        if (css(child, \"display\") === \"none\" || child === Sortable.ghost)\n          return;\n        animationStates.push({\n          target: child,\n          //@ts-ignore\n          rect: getRect(child),\n        });\n        let fromRect = { ...animationStates[animationStates.length - 1].rect };\n\n        // If animating: compensate for current animation\n        if (child.thisAnimationDuration) {\n          let childMatrix = matrix(child, true);\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n\n        child.fromRect = fromRect;\n      });\n    },\n\n    addAnimationState(state) {\n      animationStates.push(state);\n    },\n\n    removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, { target }), 1);\n    },\n\n    animateAll(callback) {\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === \"function\") callback();\n        return;\n      }\n\n      let animating = false,\n        animationTime = 0;\n\n      animationStates.forEach((state) => {\n        let time = 0,\n          animatingThis = false,\n          target = state.target,\n          fromRect = target.fromRect,\n          //@ts-ignore\n          toRect = getRect(target),\n          prevFromRect = target.prevFromRect,\n          prevToRect = target.prevToRect,\n          animatingRect = state.rect,\n          targetMatrix = matrix(target, true);\n\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n\n        target.toRect = toRect;\n\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (\n            isRectEqual(prevFromRect, toRect) &&\n            !isRectEqual(fromRect, toRect) &&\n            // Make sure animatingRect is on line between toRect & fromRect\n            (animatingRect.top - toRect.top) /\n              (animatingRect.left - toRect.left) ===\n              (fromRect.top - toRect.top) / (fromRect.left - toRect.left)\n          ) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(\n              animatingRect,\n              prevFromRect,\n              prevToRect,\n              this.options\n            );\n          }\n        }\n\n        // if fromRect != toRect: animate\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n\n          if (!time) {\n            time = this.options.animation;\n          }\n          this.animate(target, animatingRect, toRect, time);\n        }\n\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n\n      clearTimeout(animationCallbackId);\n      if (!animating) {\n        if (typeof callback === \"function\") callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === \"function\") callback();\n        }, animationTime);\n      }\n      animationStates = [];\n    },\n\n    animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, \"transition\", \"\");\n        css(target, \"transform\", \"\");\n        //@ts-ignore\n        let elMatrix = matrix(this.el),\n          scaleX = elMatrix && elMatrix.a,\n          scaleY = elMatrix && elMatrix.d,\n          translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n          translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n\n        css(\n          target,\n          \"transform\",\n          \"translate3d(\" + translateX + \"px,\" + translateY + \"px,0)\"\n        );\n\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(\n          target,\n          \"transition\",\n          \"transform \" +\n            duration +\n            \"ms\" +\n            (this.options.easing ? \" \" + this.options.easing : \"\")\n        );\n        css(target, \"transform\", \"translate3d(0,0,0)\");\n        typeof target.animated === \"number\" && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, \"transition\", \"\");\n          css(target, \"transform\", \"\");\n          target.animated = false;\n\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    },\n  };\n}\n\nfunction repaint(target) {\n  return target.offsetWidth;\n}\n\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return (\n    (Math.sqrt(\n      Math.pow(fromRect.top - animatingRect.top, 2) +\n        Math.pow(fromRect.left - animatingRect.left, 2)\n    ) /\n      Math.sqrt(\n        Math.pow(fromRect.top - toRect.top, 2) +\n          Math.pow(fromRect.left - toRect.left, 2)\n      )) *\n    options.animation\n  );\n}\n","import {\n  toggleClass,\n  getRect,\n  index,\n  closest,\n  on,\n  off,\n  clone,\n  css,\n  setRect,\n  unsetRect,\n  matrix,\n  expando,\n} from \"../../../utils/src\";\n\nimport dispatchEvent from \"../../../sortable/src/EventDispatcher\";\n\nlet multiDragElements = [],\n  multiDragClones = [],\n  lastMultiDragSelect, // for selection with modifier key down (SHIFT)\n  multiDragSortable,\n  initialFolding = false, // Initial multi-drag fold when drag started\n  folding = false, // Folding any other time\n  dragStarted = false,\n  dragEl,\n  clonesFromRect,\n  clonesHidden;\n\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (let fn in this) {\n      if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n\n    if (sortable.options.supportPointer) {\n      on(document, \"pointerup\", this._deselectMultiDrag);\n    } else {\n      on(document, \"mouseup\", this._deselectMultiDrag);\n      on(document, \"touchend\", this._deselectMultiDrag);\n    }\n\n    on(document, \"keydown\", this._checkKeyDown);\n    on(document, \"keyup\", this._checkKeyUp);\n\n    this.defaults = {\n      selectedClass: \"sortable-selected\",\n      multiDragKey: null,\n      setData(dataTransfer, dragEl) {\n        let data = \"\";\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach((multiDragElement, i) => {\n            data += (!i ? \"\" : \", \") + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n        dataTransfer.setData(\"Text\", data);\n      },\n    };\n  }\n\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n\n    delayStartGlobal({ dragEl: dragged }) {\n      dragEl = dragged;\n    },\n\n    delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl);\n    },\n\n    setupClone({ sortable, cancel }) {\n      if (!this.isMultiDrag) return;\n      for (let i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style[\"will-change\"] = \"\";\n\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl &&\n          toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n\n      sortable._hideClone();\n      cancel();\n    },\n\n    clone({ sortable, rootEl, dispatchSortableEvent, cancel }) {\n      if (!this.isMultiDrag) return;\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent(\"clone\");\n\n          cancel();\n        }\n      }\n    },\n\n    showClone({ cloneNowShown, rootEl, cancel }) {\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach((clone) => {\n        css(clone, \"display\", \"\");\n      });\n\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n\n    hideClone({ sortable, cloneNowHidden, cancel }) {\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach((clone) => {\n        css(clone, \"display\", \"none\");\n        if (this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n\n    dragStartGlobal({ sortable }) {\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n\n      multiDragElements.forEach((multiDragElement) => {\n        //@ts-ignore\n        multiDragElement.sortableIndex = index(multiDragElement);\n      });\n\n      // Sort multi-drag elements\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n\n    dragStarted({ sortable }) {\n      if (!this.isMultiDrag) return;\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n\n        sortable.captureAnimationState();\n\n        if (this.options.animation) {\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            css(multiDragElement, \"position\", \"absolute\");\n          });\n\n          //@ts-ignore\n          let dragRect = getRect(dragEl, false, true, true);\n\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            setRect(multiDragElement, dragRect);\n          });\n\n          folding = true;\n          initialFolding = true;\n        }\n      }\n\n      sortable.animateAll(() => {\n        folding = false;\n        initialFolding = false;\n\n        if (this.options.animation) {\n          multiDragElements.forEach((multiDragElement) => {\n            unsetRect(multiDragElement);\n          });\n        }\n\n        // Remove all auxiliary multidrag items from el, if sorting enabled\n        if (this.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n\n    dragOver({ target, completed, cancel }) {\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n\n    revert({ fromSortable, rootEl, sortable, dragRect }) {\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach((multiDragElement) => {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            //@ts-ignore\n            rect: folding ? getRect(multiDragElement) : dragRect,\n          });\n\n          unsetRect(multiDragElement);\n\n          multiDragElement.fromRect = dragRect;\n\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n\n    dragOverCompleted({\n      sortable,\n      isOwner,\n      insertion,\n      activeSortable,\n      parentEl,\n      putSortable,\n    }) {\n      let options = this.options;\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n\n        initialFolding = false;\n        // If leaving sort:false root, or already folding - Fold to new location\n        if (\n          options.animation &&\n          multiDragElements.length > 1 &&\n          (folding ||\n            (!isOwner && !activeSortable.options.sort && !putSortable))\n        ) {\n          //@ts-ignore\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          let dragRectAbsolute = getRect(dragEl, false, true, true);\n\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            setRect(multiDragElement, dragRectAbsolute);\n\n            // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n            parentEl.appendChild(multiDragElement);\n          });\n\n          folding = true;\n        }\n\n        // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n\n          if (multiDragElements.length > 1) {\n            let clonesHiddenBefore = clonesHidden;\n            activeSortable._showClone(sortable);\n\n            // Unfold animation for clones if showing from hidden\n            if (\n              activeSortable.options.animation &&\n              !clonesHidden &&\n              clonesHiddenBefore\n            ) {\n              multiDragClones.forEach((clone) => {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect,\n                });\n\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n\n    dragOverAnimationCapture({ dragRect, isOwner, activeSortable }) {\n      multiDragElements.forEach((multiDragElement) => {\n        multiDragElement.thisAnimationDuration = null;\n      });\n\n      if (\n        activeSortable.options.animation &&\n        !isOwner &&\n        activeSortable.multiDrag.isMultiDrag\n      ) {\n        clonesFromRect = Object.assign({}, dragRect);\n        let dragMatrix = matrix(dragEl, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n\n    dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n\n    drop({\n      originalEvent: evt,\n      rootEl,\n      parentEl,\n      sortable,\n      dispatchSortableEvent,\n      oldIndex,\n      putSortable,\n    }) {\n      let toSortable = putSortable || this.sortable;\n\n      if (!evt) return;\n\n      let options = this.options,\n        children = parentEl.children;\n\n      // Multi-drag selection\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n        toggleClass(\n          dragEl,\n          options.selectedClass,\n          !~multiDragElements.indexOf(dragEl)\n        );\n\n        if (!~multiDragElements.indexOf(dragEl)) {\n          multiDragElements.push(dragEl);\n          dispatchEvent({\n            sortable,\n            rootEl,\n            name: \"select\",\n            targetEl: dragEl,\n            //@ts-ignore\n            originalEvt: evt,\n          });\n\n          // Modifier activated, select from last to dragEl\n          if (\n            evt.shiftKey &&\n            lastMultiDragSelect &&\n            sortable.el.contains(lastMultiDragSelect)\n          ) {\n            //@ts-ignore\n            let lastIndex = index(lastMultiDragSelect),\n              //@ts-ignore\n              currentIndex = index(dragEl);\n\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n              // (but previous selection existed)\n              let n, i;\n              if (currentIndex > lastIndex) {\n                i = lastIndex;\n                n = currentIndex;\n              } else {\n                i = currentIndex;\n                n = lastIndex + 1;\n              }\n\n              for (; i < n; i++) {\n                if (~multiDragElements.indexOf(children[i])) continue;\n                toggleClass(children[i], options.selectedClass, true);\n                multiDragElements.push(children[i]);\n\n                dispatchEvent({\n                  sortable,\n                  rootEl,\n                  name: \"select\",\n                  targetEl: children[i],\n                  //@ts-ignore\n                  originalEvt: evt,\n                });\n              }\n            }\n          } else {\n            lastMultiDragSelect = dragEl;\n          }\n\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable,\n            rootEl,\n            name: \"deselect\",\n            targetEl: dragEl,\n            //@ts-ignore\n            originalEvt: evt,\n          });\n        }\n      }\n\n      // Multi-drag drop\n      if (dragStarted && this.isMultiDrag) {\n        // Do not \"unfold\" after around dragEl if reverted\n        if (\n          (parentEl[expando].options.sort || parentEl !== rootEl) &&\n          multiDragElements.length > 1\n        ) {\n          //@ts-ignore\n          let dragRect = getRect(dragEl),\n            multiDragIndex = index(\n              dragEl,\n              \":not(.\" + this.options.selectedClass + \")\"\n            );\n\n          if (!initialFolding && options.animation)\n            dragEl.thisAnimationDuration = null;\n\n          toSortable.captureAnimationState();\n\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl.fromRect = dragRect;\n              multiDragElements.forEach((multiDragElement) => {\n                multiDragElement.thisAnimationDuration = null;\n                if (multiDragElement !== dragEl) {\n                  //@ts-ignore\n                  let rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect;\n\n                  // Prepare unfold animation\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect,\n                  });\n                }\n              });\n            }\n\n            // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n            removeMultiDragElements();\n\n            multiDragElements.forEach((multiDragElement) => {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(\n                  multiDragElement,\n                  children[multiDragIndex]\n                );\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n              multiDragIndex++;\n            });\n\n            // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n            //@ts-ignore\n            if (oldIndex === index(dragEl)) {\n              let update = false;\n              multiDragElements.forEach((multiDragElement) => {\n                //@ts-ignore\n                if (\n                  //@ts-ignore\n                  multiDragElement.sortableIndex !== index(multiDragElement)\n                ) {\n                  update = true;\n                  return;\n                }\n              });\n\n              if (update) {\n                dispatchSortableEvent(\"update\");\n              }\n            }\n          }\n\n          // Must be done after capturing individual rects (scroll bar)\n          multiDragElements.forEach((multiDragElement) => {\n            unsetRect(multiDragElement);\n          });\n\n          toSortable.animateAll();\n        }\n\n        multiDragSortable = toSortable;\n      }\n\n      // Remove clones if necessary\n      if (\n        rootEl === parentEl ||\n        (putSortable && putSortable.lastPutMode !== \"clone\")\n      ) {\n        multiDragClones.forEach((clone) => {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n\n    nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n\n    destroyGlobal() {\n      this._deselectMultiDrag();\n      off(document, \"pointerup\", this._deselectMultiDrag);\n      off(document, \"mouseup\", this._deselectMultiDrag);\n      off(document, \"touchend\", this._deselectMultiDrag);\n\n      off(document, \"keydown\", this._checkKeyDown);\n      off(document, \"keyup\", this._checkKeyUp);\n    },\n\n    _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return;\n\n      // Only deselect if selection is in this sortable\n      if (multiDragSortable !== this.sortable) return;\n\n      // Only deselect if target is not item in this sortable\n      if (\n        evt &&\n        closest(evt.target, this.options.draggable, this.sortable.el, false)\n      )\n        return;\n\n      // Only deselect if left click\n      if (evt && evt.button !== 0) return;\n\n      while (multiDragElements.length) {\n        let el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: \"deselect\",\n          //@ts-ignore\n          targetEl: el,\n          //@ts-ignore\n          originalEvt: evt,\n        });\n      }\n    },\n\n    _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n\n    _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    },\n  };\n\n  return Object.assign(MultiDrag, {\n    // Static methods & properties\n    pluginName: \"multiDrag\",\n    utils: {\n      /**\n       * Selects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be selected\n       */\n      select(el) {\n        let sortable = el.parentNode[expando];\n        if (\n          !sortable ||\n          !sortable.options.multiDrag ||\n          ~multiDragElements.indexOf(el)\n        )\n          return;\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n          multiDragSortable = sortable;\n        }\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n      /**\n       * Deselects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be deselected\n       */\n      deselect(el) {\n        let sortable = el.parentNode[expando],\n          index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      },\n    },\n    eventProperties() {\n      const oldIndicies = [],\n        newIndicies = [];\n\n      multiDragElements.forEach((multiDragElement) => {\n        oldIndicies.push({\n          multiDragElement,\n          index: multiDragElement.sortableIndex,\n        });\n\n        // multiDragElements will already be sorted if folding\n        let newIndex;\n        if (folding && multiDragElement !== dragEl) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(\n            multiDragElement,\n            \":not(.\" + this.options.selectedClass + \")\"\n          );\n        } else {\n          //@ts-ignore\n          newIndex = index(multiDragElement);\n        }\n        newIndicies.push({\n          multiDragElement,\n          index: newIndex,\n        });\n      });\n      return {\n        items: [...multiDragElements],\n        clones: [...multiDragClones],\n        oldIndicies,\n        newIndicies,\n      };\n    },\n    optionListeners: {\n      multiDragKey(key) {\n        key = key.toLowerCase();\n        if (key === \"ctrl\") {\n          key = \"Control\";\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n        return key;\n      },\n    },\n  });\n}\n\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach((multiDragElement, i) => {\n    let target =\n      rootEl.children[\n        multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)\n      ];\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n\n/**\n * Insert multi-drag clones\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\n * @param  {HTMLElement} rootEl\n */\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach((clone, i) => {\n    let target =\n      rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\n\nfunction removeMultiDragElements() {\n  multiDragElements.forEach((multiDragElement) => {\n    if (multiDragElement === dragEl) return;\n    multiDragElement.parentNode &&\n      multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\n\nexport default MultiDragPlugin;\n","import { getChild } from \"../../../utils/src\";\n\nconst drop = function ({\n  originalEvent,\n  putSortable,\n  dragEl,\n  activeSortable,\n  dispatchSortableEvent,\n  hideGhostForTarget,\n  unhideGhostForTarget,\n}) {\n  if (!originalEvent) return;\n  let toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  let touch =\n    originalEvent.changedTouches && originalEvent.changedTouches.length\n      ? originalEvent.changedTouches[0]\n      : originalEvent;\n  let target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent(\"spill\");\n    this.onSpill({ dragEl, putSortable });\n  }\n};\n\nfunction Revert() {}\n\nRevert.prototype = {\n  startIndex: null,\n  dragStart({ oldDraggableIndex }) {\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill({ dragEl, putSortable }) {\n    this.sortable.captureAnimationState();\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n    let nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n    this.sortable.animateAll();\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop,\n};\n\nObject.assign(Revert, {\n  pluginName: \"revertOnSpill\",\n});\n\nfunction Remove() {}\n\nRemove.prototype = {\n  onSpill({ dragEl, putSortable }) {\n    const parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop,\n};\n\nObject.assign(Remove, {\n  pluginName: \"removeOnSpill\",\n});\n\nexport default [Remove, Revert];\n\nexport { Remove as RemoveOnSpill, Revert as RevertOnSpill };\n","import {\n  on,\n  off,\n  css,\n  throttle,\n  cancelThrottle,\n  scrollBy,\n  getParentAutoScrollElement,\n  expando,\n  getRect,\n  getWindowScrollingElement,\n  Edge,\n  IE11OrLess,\n  Safari,\n} from \"../../../utils/src\";\n\nimport Sortable from \"../../../sortable/src/Sortable\";\n\nlet autoScrolls = [],\n  scrollEl,\n  scrollRootEl,\n  scrolling = false,\n  lastAutoScrollX,\n  lastAutoScrollY,\n  touchEvt,\n  pointerElemChangedInterval;\n\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true,\n    };\n\n    // Bind all private methods\n    for (let fn in this) {\n      if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n\n  AutoScroll.prototype = {\n    dragStarted({ originalEvent }) {\n      if (this.sortable.nativeDraggable) {\n        on(document, \"dragover\", this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, \"pointermove\", this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, \"touchmove\", this._handleFallbackAutoScroll);\n        } else {\n          on(document, \"mousemove\", this._handleFallbackAutoScroll);\n        }\n      }\n    },\n\n    dragOverCompleted({ originalEvent }) {\n      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n\n    drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, \"dragover\", this._handleAutoScroll);\n      } else {\n        off(document, \"pointermove\", this._handleFallbackAutoScroll);\n        off(document, \"touchmove\", this._handleFallbackAutoScroll);\n        off(document, \"mousemove\", this._handleFallbackAutoScroll);\n      }\n\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n\n    nulling() {\n      touchEvt = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n\n      autoScrolls.length = 0;\n    },\n\n    _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n\n    _handleAutoScroll(evt, fallback) {\n      const x = (evt.touches ? evt.touches[0] : evt).clientX,\n        y = (evt.touches ? evt.touches[0] : evt).clientY,\n        elem = document.elementFromPoint(x, y);\n\n      touchEvt = evt;\n\n      // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n      if (fallback || Edge || IE11OrLess || Safari) {\n        //@ts-ignore\n        autoScroll(evt, this.options, elem, fallback);\n\n        // Listener for pointer element change\n        let ogElemScroller = getParentAutoScrollElement(elem, true);\n        if (\n          scrolling &&\n          (!pointerElemChangedInterval ||\n            x !== lastAutoScrollX ||\n            y !== lastAutoScrollY)\n        ) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval();\n          // Detect for pointer elem change, emulating native DnD behaviour\n          pointerElemChangedInterval = setInterval(() => {\n            let newElem = getParentAutoScrollElement(\n              document.elementFromPoint(x, y),\n              true\n            );\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n            //@ts-ignore\n            autoScroll(evt, this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (\n          !this.options.bubbleScroll ||\n          getParentAutoScrollElement(elem, true) === getWindowScrollingElement()\n        ) {\n          clearAutoScrolls();\n          return;\n        }\n        autoScroll(\n          //@ts-ignore\n          evt,\n          this.options,\n          getParentAutoScrollElement(elem, false),\n          false\n        );\n      }\n    },\n  };\n\n  return Object.assign(AutoScroll, {\n    pluginName: \"scroll\",\n    initializeByDefault: true,\n  });\n}\n\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\n\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\n\nconst autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  const x = (evt.touches ? evt.touches[0] : evt).clientX,\n    y = (evt.touches ? evt.touches[0] : evt).clientY,\n    sens = options.scrollSensitivity,\n    speed = options.scrollSpeed,\n    winScroller = getWindowScrollingElement();\n\n  let scrollThisInstance = false,\n    scrollCustomFn;\n\n  // New scroll root, set scrollEl\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n\n    clearAutoScrolls();\n\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n\n  let layersOut = 0;\n  let currentParent = scrollEl;\n  do {\n    let el = currentParent,\n      //@ts-ignore\n      rect = getRect(el),\n      top = rect.top,\n      bottom = rect.bottom,\n      left = rect.left,\n      right = rect.right,\n      width = rect.width,\n      height = rect.height,\n      canScrollX,\n      canScrollY,\n      scrollWidth = el.scrollWidth,\n      scrollHeight = el.scrollHeight,\n      //@ts-ignore\n      elCSS = css(el),\n      scrollPosX = el.scrollLeft,\n      scrollPosY = el.scrollTop;\n\n    if (el === winScroller) {\n      canScrollX =\n        width < scrollWidth &&\n        (elCSS.overflowX === \"auto\" ||\n          elCSS.overflowX === \"scroll\" ||\n          elCSS.overflowX === \"visible\");\n      canScrollY =\n        height < scrollHeight &&\n        (elCSS.overflowY === \"auto\" ||\n          elCSS.overflowY === \"scroll\" ||\n          elCSS.overflowY === \"visible\");\n    } else {\n      canScrollX =\n        width < scrollWidth &&\n        (elCSS.overflowX === \"auto\" || elCSS.overflowX === \"scroll\");\n      canScrollY =\n        height < scrollHeight &&\n        (elCSS.overflowY === \"auto\" || elCSS.overflowY === \"scroll\");\n    }\n\n    let vx =\n      canScrollX &&\n      //@ts-ignore\n      (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) -\n        //@ts-ignore\n        (Math.abs(left - x) <= sens && !!scrollPosX);\n    let vy =\n      canScrollY &&\n      //@ts-ignore\n      (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) -\n        //@ts-ignore\n        (Math.abs(top - y) <= sens && !!scrollPosY);\n\n    if (!autoScrolls[layersOut]) {\n      for (let i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n\n    if (\n      autoScrolls[layersOut].vx != vx ||\n      autoScrolls[layersOut].vy != vy ||\n      autoScrolls[layersOut].el !== el\n    ) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n\n      clearInterval(autoScrolls[layersOut].pid);\n\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n        autoScrolls[layersOut].pid = setInterval(\n          function () {\n            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n            if (isFallback && this.layer === 0) {\n              //@ts-ignore\n              Sortable.active._onTouchMove(touchEvt); // To move ghost if it is positioned absolutely\n            }\n            let scrollOffsetY = autoScrolls[this.layer].vy\n              ? autoScrolls[this.layer].vy * speed\n              : 0;\n            let scrollOffsetX = autoScrolls[this.layer].vx\n              ? autoScrolls[this.layer].vx * speed\n              : 0;\n\n            if (typeof scrollCustomFn === \"function\") {\n              if (\n                scrollCustomFn.call(\n                  //@ts-ignore\n                  Sortable.dragged.parentNode[expando],\n                  scrollOffsetX,\n                  scrollOffsetY,\n                  evt,\n                  touchEvt,\n                  autoScrolls[this.layer].el\n                ) !== \"continue\"\n              ) {\n                return;\n              }\n            }\n\n            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n          }.bind({ layer: layersOut }),\n          24\n        );\n      }\n    }\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\n\nexport default AutoScrollPlugin;\n","import Sortable from \"../../sortable/src/Sortable\";\nimport Swap from \"../../plugins/swap/src\";\nimport MultiDrag from \"../../plugins/multi-drag/src\";\nimport { RemoveOnSpill, RevertOnSpill } from \"../../plugins/on-spill/src\";\nimport AutoScroll from \"../../plugins/auto-scroll/src\";\n\n//@ts-ignore\nSortable.mount(new AutoScroll());\nSortable.mount(RemoveOnSpill, RevertOnSpill);\n//@ts-ignore\nSortable.mount(new Swap());\n//@ts-ignore\nSortable.mount(new MultiDrag());\n\nexport default Sortable;\nexport { Sortable };\n","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { mapToCssModules, tagPropType } from './utils';\nvar propTypes = {\n  tag: tagPropType,\n  className: PropTypes.string,\n  cssModule: PropTypes.object,\n  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func])\n};\nvar defaultProps = {\n  tag: 'div'\n};\n\nvar CardBody = function CardBody(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      innerRef = props.innerRef,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, [\"className\", \"cssModule\", \"innerRef\", \"tag\"]);\n\n  var classes = mapToCssModules(classNames(className, 'card-body'), cssModule);\n  return /*#__PURE__*/React.createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    ref: innerRef\n  }));\n};\n\nCardBody.propTypes = propTypes;\nCardBody.defaultProps = defaultProps;\nexport default CardBody;"],"sourceRoot":""}